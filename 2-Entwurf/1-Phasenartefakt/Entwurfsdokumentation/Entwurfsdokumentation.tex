\documentclass[parskip=full]{scrartcl}

\usepackage[utf8]{inputenc}			% Umlaute, Sonderzeichen
\usepackage[ngerman]{babel}			% deutsche Sprache
\usepackage{enumitem}				% Listen
\usepackage{graphicx}				% Grafiken
\usepackage{hyperref}				% Hyperlinks
\usepackage[nonumberlist]{glossaries}		% Glossar
\usepackage{amsmath}

% Hurenkinder und Schusterjungen verhindern
\clubpenalty10000
\widowpenalty10000
\displaywidowpenalty=10000

\DeclareRobustCommand{\glossfirstformat}[1]{\textit{#1}}	% der erste Verweis im Dokument auf ...
\renewcommand*{\glsdisplayfirst}[4]{\glossfirstformat{#1#4}}	% ... einen Glossarbegriff wird kursiv markiert

% Kriterien sollen nicht kursiv erscheinen
\makeatletter
\renewcommand{\@begintheorem}[2]{\trivlist
	\item[\hskip \labelsep{\bfseries #1\ #2}]}
\makeatother


\makenoidxglossaries

\newglossaryentry{RasPi}{
	name=Raspberry Pi,
	plural=Raspberry Pis,
	description={Der Raspberry Pi ist ein Einplatinencomputer. In diesem Projekt dient der Raspberry Pi als Hardwareplattform, um Messwerte aus angeschlossenen Sensoren auszulesen}
}

\newglossaryentry{PhyPiDAQ}{
	name=PhyPiDAQ,
	description={PhyPiDAQ ist ein Framework zur Erfassung und Analyse von Messwerten mit einem Raspberry Pi. Siehe auch Abschnitt 4.3 ,,PhyPiDAQ`` sowie \url{https://github.com/GuenterQuast/PhyPiDAQ}}
}

\newglossaryentry{Science Labs}{
	name=Science Labs,
	description={Ein Science Lab ist ein Arbeitsplatz, welcher Schülern ermöglicht, wissenschaftliche Forschungen unter kontrollierten Bedingungen durchzuführen} 
}

\newglossaryentry{opensource}{
	name=Open Source,
	description={Software, deren Quelltext öffentlich eingesehen eingesehen werden kann, wird als ,,Open Source`` bzw. ,,quelloffen`` bezeichnet} 
}

\newglossaryentry{osl2}{
	name=OSL\textsuperscript{2},
	description={Open-Source-Lehrsoftware-Labor, siehe \url{https://formal.iti.kit.edu/projects/oslsl/?lang=de}}
}

\newglossaryentry{dragdrop}{
	name=Drag and Drop,
	description={Methode, um mit grafischen Benutzeroberflächen zu interagieren. Dabei wird ein Objekt erst mit der Maus festgehalten und an einen anderen Ort gezogen. Durch das Lösen der Maustaste wird das Objekt platziert}
}

\newglossaryentry{click}{
	name=Click,
	description={Betätigen der linken Maustaste}
}

\newglossaryentry{transformation}{
	name=Transformation,
	plural={Transformationen},
	description={Bausteine vom Typ Transformation haben einen oder mehrere Eingänge sowie einen oder mehrere Ausgänge. Für jeden Ausgang kann  ein Transformationsbaustein eine Vorschrift zur Berechnung eines Ausgangswertes aus einem Satz von Eingangswerten beinhalten. Eine Berechnungsvorschrift soll durch eine mathematische bzw. logische Funktionen oder durch eine programmtechnisch definierte Verarbeitung definiert werden können}
}

\newglossaryentry{konfigdata}{
	name=Konfigurationsdatei,
	plural=Konfigurationsdateien,
	description={Können das Messverhalten anpassen, beispielsweise die Anzahl der Messungen pro Zeiteinheit. Für jeden Sensor gibt es eine eigene Konfigurationsdatei}
}

\newglossaryentry{sensor}{
	name=Sensor,
	plural={Sensoren},
	description={Der Begriff ,,Sensor`` bezeichnet ein technisches Bauteil, welches physikalische Größen misst und analoge oder digitale Messwerte liefert. In unserer Anwendung werden Sensoren abstrakt als grafische Bausteine eines Messkonfiguration präsentiert. Ein solcher (logischer) Sensorbaustein muss alle Informationen referenzieren können, die zum Ansprechen eines tatsächlichen Sensors benötigt werden. Da ein Messgerät Ausgänge bzw. Messkanäle haben kann, muss ein Sensorbaustein mindestens einen oder auch mehrere Ausgänge haben. Eingänge besitzt ein Sensorbaustein nicht}
}

\newglossaryentry{messdaten}{
	name=Messdaten,
	description={Daten, welche die Anwendung von einem Sensor (über PhyPiDAQ-Schnittstelle) oder direkt aus einer Datei erhält}
}

\newglossaryentry{darstellung}{
	name=Darstellung,
	plural={Darstellungen},
	description={Bausteine vom Typ Darstellung haben einen oder mehrere Eingänge. Ein Darstellungsbaustein soll definieren können, wie ein Satz von Eingangswerten die Erstellung bzw. Aktualisierung einer Darstellung beeinflusst. Ausgänge besitzt ein Darstellungsbaustein nicht}
}

\newglossaryentry{python3}{
	name=Python 3,
	description={Python ist eine Skriptsprache, die auf dem Raspberry Pi als Standardsprache zur Programmierung vorgesehen ist. Python wurde zur Implementierung von PhyPiDAQ verwendet}
}

\newglossaryentry{JVM}{
	name={Java Virtual Machine},
	description={Die Java Virtual Machine (JVM) ist eine Plattform für die Ausführung von Java-Software, die von der Firma Oracle für alle gängigen Betriebssysteme bereitgestellt wird}
}

\newglossaryentry{DSGVO}{
	name=DSGVO,
	first={Datenschutz-Grundverordnung (DSGVO)},
	description ={Datenschutz-Grundverordnung der Europäischen Union vom 25. Mai 2018}
}

\newglossaryentry{Musskriterien}{
	name=Musskriterien,
	description ={Werden zusammen mit Soll- und Wunschkriterien bei der Abnahme eines Softwareprodukts überprüft und haben während der Entwicklung höchste Priorität. 
	Dass ein Musskriterium in den nachfolgenden Projektphasen nicht umgesetzt wird, ist nur dann zulässig, falls unerwartet unausweichliche Probleme bei der Umsetzung auftreten. 
	In diesem Fall ist es erforderlich, dass diese Probleme sehr genau dokumentiert werden}
}

\newglossaryentry{Sollkriterien}{
	name=Sollkriterien,
	description ={Werden zusammen mit Muss- und Wunschkriterien bei der Abnahme eines Softwareprodukts überprüft und haben während der Entwicklung mittlere Priorität. 
	Falls ein Sollkriterium umgesetzt werden kann, dann muss es nach Möglichkeit auch realisiert werden. 
	Falls ein Sollkriterium in den nachfolgenden Projektphasen nicht umgesetzt werden kann, so muss dies dokumentiert und begründet werden}
}

\newglossaryentry{Wunschkriterien}{
	name=Wunschkriterien,
	description ={Werden zusammen mit Muss- und Sollkriterien bei der Abnahme eines Softwareprodukts überprüft und haben während der Entwicklung eine niedrige Priorität. 
	Je nach Resourcenlage können sie nach Bearbeitung aller Muss- und Kannkriterien umgesetzt werden. 
	Falls ein Wunschkriterium nicht umgesetzt wird, so muss dies nicht begründet werden}
}

\newglossaryentry{Abgrenzungskriterien}{
	name=Abgrenzungskriterien,
	description ={Abgrenzungskriterien beschreiben Aspekte, die explizit nicht umgesetzt werden sollen.}
}

\newglossaryentry{BenOber}{
	name=Benutzeroberfläche,
	description = {Steht für die Oberfläche, die der Benutzer verwendet um die Anwendung zu bedienen}
}

\newglossaryentry{UI}{
	name=UI,
	description={engl. User Interface; siehe: Benutzeroberfläche}
}

\newglossaryentry{GrafBenOber}{
	name=grafische Benutzeroberfläche,
	description = {Eine Benutzungsschnittstelle, die eine Anwendung durch Fenster, grafische Symbole, Menüs und Mauszeiger bedienbar macht}
}

\newglossaryentry{GUI}{
	name=GUI,
	description={engl. Graphical User Interface; siehe: Grafische Benutzeroberfläche},
}

\newglossaryentry{Konfigurationsbaustein}{
	name=Konfigurationsbaustein,
	plural=Konfigurationsbausteine,
	description ={Teil einer Messkonfiguration, der eine Teilaufgabe bestimmten Typs erfüllen kann. Es gibt Sensorbausteine, Konfigurationsbausteine und Darstellungsbausteine. Liegt am Ausgang eines Bausteins ein Wert an, so kann dieser an den Eingang eines nachgelagerten Bausteins weitergeleitet werden}
}

\newglossaryentry{Benutzerkonfiguration}{
	name =Messkonfiguration,
	plural=Messkonfigurationen,
	description ={Gerichteter zyklenfreier Graph mit Knoten vom Typ Sensor, Transformation oder Darstellung. Hierbei ist zu beachten, dass Sensoren keine Eingangskanten und Darstellungen keine Ausgangskanten haben dürfen}
}

\newglossaryentry{Bausteinprototyp}{
	name=Bausteinprototyp,
	plural=Bausteinprototypen,
	description={Baustein, von dem eine Kopie angelegt wird, wenn der Benutzer ein neues Baustein-Exemplar einem Entwurf hinzufügen möchte}
}

\newglossaryentry{Messlauf}{
	name=Messlauf,
	plural=Messläufe,
	description={Zeitabschnitt, in dem zu definierten Zeitpunkten an allen Bausteinen eines Entwurfs sukzessive die Werte an allen Ausgängen und Eingängen bestimmt werden}
}

\newglossaryentry{Stand-Alone-Kommunikation}{
	name={Stand-Alone-Kommunikation},
	description={Bezeichnet im Kontext unseres Software-Projekt die systeminterne Kommunikation innerhalb eines Betriebssystems, beispielsweise per Inter-Prozess-Kommunikation (IPC)}
	}


\newglossaryentry{Local-Loop}{
	name={Local-Loop},
	description={Bezeichnet einen virtuellen Netzwerkadapter, der Pakete, die durch ihn verschickt werden, unmittelbar danach auch wieder empfängt.}
}

\newglossaryentry{Model-View-Controller}{
	name={Model-View-Controller},
	description={Architekturmuster, dass die Software in die drei Komponenten: Model, View und Controller unterteilt. Dadurch sollen die einzelnen Komponenten unabhängig von einander verändert werden können.}
}

\subject{Entwurfsdokumentation}
\title{Visuelle Programmiersprache für den Physikunterricht zur Datenerfassung auf einem Raspberry Pi}
\subtitle{Version 0.0.0}
\author{David Gawron \and Stefan Geretschläger \and Leon Huck \and Jan Küblbeck \and Linus Ruhnke}
\date{\today}


\begin{document}

\maketitle

\clearpage
\tableofcontents 					% generate pdf twice to update

\clearpage
\section{Ziel der Entwurfsdokumentation} \label{einleitung}
Die Entwurfsdokumentation soll, aufbauend auf das Pflichtenheft, Entwurfsentscheidungen festhalten. Der Rahmen des Entwurfes wird durch einen \gls{Model-View-Controller} (MVC) gebildet. Die Daten werden durch das Backend zu der Verfügung gestellt. Jedes dieser Pakete kommuniziert über eine Fassade. Dadurch werden die Pakete von einander abgekoppelt.
Durch diesen grundlegenden Aufbau wird die Software in vier unabhängige Komponenten aufgeteilt, die unabhängig voneinander implementiert und später erweitert werden können.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 14cm]{Grafiken/Grober_Aufbau.png}
		\caption{Die grobe Struktur des Entwurfs}
		\label{Entwurf_Grob}
	\end{center}
\end{figure}


\clearpage
\section{Klassenbeschreibung}
Im folgenden sollen alle Klassen mit ihren Funktion beschrieben werden. Der Aufbau orientiert sich dabei an der in \ref{einleitung} aufgeführten Struktur.

\clearpage
\subsection{Backend}


\clearpage
\subsection{Model}


\subsubsection{Core}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 16cm]{Grafiken/ModelCore.png}
		\caption{Aufbau des Pakets Core}
		\label{ModelCore}
	\end{center}
\end{figure}

Die Struktur des Pakets Core ist in Abbildung \ref{ModelCore} zu sehen.
TODO



\paragraph{BuildingBlockDirectory}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 8cm]{Grafiken/BuildingBlockDirectory.png}
		\caption{Darstellung der Klasse BuildingBlockDirectory}
		\label{BuildingBlockDirectory}
	\end{center}
\end{figure}
Die Klasse BuildingBlockDirectory ist in Abbildung \ref{BuildingBlockDirectory} zu sehen.
TODO


\paragraph{MeasurementConfiguration}
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 8cm]{Grafiken/MeasurementConfiguration.png}
		\caption{Darstellung der Klasse MeasurementConfiguration}
		\label{MeasurementConfiguration}
	\end{center}
\end{figure}
Die Klasse MeasurementConfiguration ist in Abbildung \ref{MeasurementConfiguration} zu sehen.
TODO

\paragraph{MeasurementRun}
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 8cm]{Grafiken/MeasurementRun.png}
		\caption{Darstellung der Klasse MeasurementRun}
		\label{MeasurementRun}
	\end{center}
\end{figure}
Die Klasse MeasurementRun ist in Abbildung \ref{MeasurementRun} zu sehen.
TODO

\subsubsection{BuildingBlock}
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 7cm]{Grafiken/BuildingBlock.png}
		\caption{Darstellung der Klasse BuildingBlock}
		\label{BuildingBlock}
	\end{center}
\end{figure}

Die abstrakte Klasse BuildingBlock ist in Abbildung \ref{BuildingBlock} zu sehen. Sie stellt im Model einen BuildingBlock dar und speichert die nötigen Daten als folgende Attribute:
\begin{itemize}

\item Das Attribut initId speichert als einen String eine eindeutige ID zur Unterscheidung von BuildingBlockPrototypen.
\item Das Attribut configId dient als eindeutige ID zur Unterscheidung von BuildingBlockInstanzen innerhalb einer Messkonfiguration, da auch mehrere BuildingBlocks eines Typs innerhalb einer Messkonfiguration auftreten können und unterschieden werden müssen.
\item Das Attribut name speichert den Namen einen BuildingBlocks als String dar. 
\item Das Attribut userInfo ?? TODO
\end{itemize}
Ein BuildingBlock hat eine beliebige Menge an In- und OutChannels, deren Anzahl durch die folgenden vier Methoden verwaltet kann:

\begin{itemize}

\item Die Methode \textit{addInChannel} fügt dem BuildingBlock einen InChannel hinzu.
\item Die Methode \textit{removeInChannel} entfernt einen bestimmen InChannel von dem BuildingBlock.
\item Die Methode \textit{addOutChannel} fügt dem BuildingBlock einen OutChannel hinzu.
\item Die Methode \textit{removeOutChannel} entfernt einen bestimmen OutChannel von dem BuildingBlock.
\item textit{setId} TODO
\end{itemize}





\paragraph{YamlRepresentation}

TODO

\paragraph{HelpMessage}
Die Klasse HelpMessage enthält einen Konstruktor HelpMessage, der ein entsprechendes HelpMessage-Objekt erstellt.
Ein HelpMessage-Objekt speichert zu einem zugehörigen BuildingBlock einen Tooltip mit Informationen über den entsprechenden BuildingBlock. Die Verbindung zu der Datei, die die Informationen enthält, ist als Attribut messageFileName gespeichert. Die Methode
\textit{displayMessage} ermöglicht es, die Informationen anzuzeigen.



\subsubsection{MRunReaction}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 8cm]{Grafiken/MRunReaction.png}
		\caption{Darstellung der Klasse MRunReaction}
		\label{MRunReaction}
	\end{center}
\end{figure}

Die Klasse MRunReaction ist in Abbildung \ref{mRunReaction} zu sehen. Sie implementiert das Interface MRunForward, welches im Cache-Modul zu finden ist. MRunReaction dient als Verbindung zwischen Cache und Modul. Der Datenfluss vom Cache zu den Sensorbausteinen im Model wird durch die folgenden fünf Methoden verwaltet.
 
Die Methode \textit{justWaiting} signalisiert dem Modul, dass eine Verbindung besteht, aber kein Datenfluss stattfindet. Durch die Methode \textit{indicateError} dient dazu, dem Model das Auftreten eines Fehlers zu signalisieren. Dabei wird als Parameter ein Fehlercode und die ID des betroffenen Eingangschannels beigefügt. 
Durch die Methode \textit{timeOut} wird eine außerplanmäßige Unterbrechung einer Verbindung signalisiert. Durch die Methode \textit{connectionTerminated} wird hingegen das planmäßige Schließen einer Verbindung signalisiert. 
Die Methode \textit{dispatchCompletePacketSet} übergibt dem Model ein Set aus Datenpaketen, so dass jeder Eingangschannel jedes Sensors in der Messkonfiguration ein Packet erhält. Ein Datenpaket besteht hier aus Wert, Zielchannel und Zeitstempel.

\subsubsection{MRunInfo}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 7cm]{Grafiken/MRunInfo.png}
		\caption{Darstellung der Klasse MRunInfo}
		\label{MRunInfo}
	\end{center}
\end{figure}

Die Klasse MRunInfo ist in Abbildung \ref{MRunInfo} zu sehen.





\subsubsection{FacadeViewModel}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 16cm]{Grafiken/FacadeViewModel.png}
		\caption{Aufbau des Pakets FacadeViewModel}
		\label{FacadeViewModel}
	\end{center}
\end{figure}

Die Struktur des Pakets FacadeViewModel ist in Abbildung \ref{FacadeViewModel} zu sehen.
TODO

\paragraph{PickUpPointViewFacades}
\paragraph{MeasurementDataInterface}
\paragraph{ExceptionInterface}
\paragraph{UpdateInterface}
\paragraph{GraphicDataIolnterface}




\subsubsection{SensorLogic}
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 12cm]{Grafiken/SensorLogic.png}
		\caption{Aufbau des Pakets SensorLogic}
		\label{SensorLogic}
	\end{center}
\end{figure}

Die Struktur des Pakets SensorLogic ist in Abbildung \ref{SensorLogic} zu sehen.
TODO


\paragraph{Sensor}
\paragraph{VirtualSensor}
\paragraph{PhysicalSensor}

\subsubsection{TransformationLogic}
\paragraph{Transformation}
\paragraph{Function}
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 12cm]{Grafiken/TransformationLogic.png}
		\caption{Aufbau des Pakets TransformationLogic}
		\label{TransformationLogic}
	\end{center}
\end{figure}

Die Struktur des Pakets TransformationLogic ist in Abbildung \ref{TransformationLogic} zu sehen.
TODO
\paragraph{Transformation}
\paragraph{Function}



\subsubsection{RepresentationLogic}
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 12cm]{Grafiken/RepresentationLogic.png}
		\caption{Aufbau des Pakets RepresentationLogic}
		\label{RepresentationLogic}
	\end{center}
\end{figure}
Die Struktur des Pakets RepresentationLogic ist in Abbildung \ref{RepresentationLogic} zu sehen.
TODO

\paragraph{Representation}
\paragraph{TableRepresentation}
\paragraph{XYRepresentation}


\subsubsection{ChannelLogic}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 16cm]{Grafiken/ChannelLogic.png}
		\caption{Aufbau des Pakets ChannelLogic}
		\label{ChannelLogic}
	\end{center}
\end{figure}

Die Struktur des Pakets ChannelLogic ist in Abbildung \ref{ChannelLogic} zu sehen.
TODO


\paragraph{Channel}
\paragraph{InChannel}
\paragraph{OutChannel}
\paragraph{ChannelState}
\paragraph{Connected}
\paragraph{UnConnected}
\paragraph{ValueReady}


\subsubsection{BuildingBlockBuilder}
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 16cm]{Grafiken/BuildingBlockBuilder.png}
		\caption{Aufbau des Pakets BuildingBlockBuilder}
		\label{BuildingBlockBuilder}
	\end{center}
\end{figure}

Der Aufbau des Pakets BuildingBlockBuilder, zu sehen in Abbildung \ref{BuildingBlockBuilder}, setzt das Enwurfsmuster Erbauer um. Die Rollen sind dabei folgendermaßen umgesetzt:
\begin{itemize}

\item Die Klasse \textit{Director} erfüllt die Rolle des \textit{Direktors}.
\item Die Klasse \textit{Builder} erfüllt die Rolle eines \textit{Erbauers}.
\item Die Klassen \textit{SensorBuilder},\textit{TransformationBuilder}, \textit{RepresentationBuilder},
\textit{VirtualSensorBuilder},\textit{PhysicalSensorBuilder},\textit{XYRepresentationBuilder} und \textit{TableRepresentationBuilder}  erfüllen die Rolle der \textit{konkreten Erbauer}.
\item Die Rollen der \textit{Produkte} werden in den Paketen \hyperlink{SensorLogic}{SensorLogic}, \hyperlink{TransformationLogic}{TransformationLogic} und \hyperlink{RepresentationLogic}{RepresentationLogic} als entsprechende Bausteine erfüllt.

\end{itemize} 
TODO Begründe warum Erbauer und kein anderes.




\paragraph{Director}
\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 7cm]{Grafiken/Director.png}
		\caption{Darstellung der Klasse Director}
		\label{Director}
	\end{center}
\end{figure}
Die Klasse Director ist in Abbildung \ref{Director} zu sehen. Sie bietet eine Reihe an \textit{construct...} Methoden an, mit denen konkrete BuildingBlocks erstellt werden können. Der resultierende BuildingBlock wird dann in einer HashMap im BuildingBlockDirectory abgelegt. Dabei kann die Auswahl an Methoden durch neue Methoden erweitert werden, um neue Arten von Blöcken erbauen zu können. Dabei muss auch jeweils ein neuer konkreter Erbauer implementiert werden. In erster Linie hat der Director die Aufgabe, beim Start der Anwendung die angebotenen Prototypen zu erstellen und im BuildingBlockDirectory zu speichern. 

\paragraph{Builder}
Die Klasse Builder ist die Oberklasse aller konkreten Builder. Sie hat als Attribut eine Verbindung zu einer Yaml-Datei. Mit Hilfe dieser Yaml-Datei kann ein entsprechender BuildingBlock erstellt werden. Die Yaml-Datei wird durch die Methode \textit{snakeYaml.load} geladen, welche durch das externe Paket SnakeYamlParser angeboten wird. Die abstrakte Methode \textit{fetchBuildingBlock} gibt die Signatur für die konkreten Erbauer vor. In den konkreten Erbauern kann der Director durch diese Methode einen entsprechenden BuildingBlock anfordern und als Rückgabewert erhalten, sobald er erbaut wurde. 

\paragraph{SensorBuilder}
Die Klasse erstellt als konkreter Erbauer durch Aufrufen der Methode \textit{fetchBuildingBlock} aus einer Yaml-Datei einen TransformationsBlock und gibt ihn als Rückgabewert zurück. Die Verbindung zu der entsprechenden Yaml-Datei wird als Attribut von der Oberklasse Builder geerbt.


\paragraph{VirtualSensorBuilder}
Die Klasse erstellt als konkreter Erbauer durch Aufrufen der Methode \textit{fetchBuildingBlock} aus einer Yaml-Datei einen VirtualsensorBlock und gibt ihn als Rückgabewert zurück. Die Verbindung zu der entsprechenden Yaml-Datei ist als geerbtes Attribut vorhanden.
\paragraph{PhysicalSensorBuilder}
Die Klasse erstellt als konkreter Erbauer durch Aufrufen der Methode \textit{fetchBuildingBlock} aus einer Yaml-Datei einen PhysicalSensorBlock und gibt ihn als Rückgabewert zurück. Die Verbindung zu der entsprechenden Yaml-Datei ist als geerbtes Attribut vorhanden. Der PhysicalSensorBuilder fügt dem Sensorblock durch die Methode \textit{addSensorProducerName} zusätzlich noch den Werknamen des Sensors hinzu.
\paragraph{TransformationBuilder}
Die Klasse erstellt als konkreter Erbauer durch Aufrufen der Methode \textit{fetchBuildingBlock} aus einer Yaml-Datei einen TransformationsBlock und gibt ihn als Rückgabewert zurück. Die Verbindung zu der entsprechenden Yaml-Datei wird als Attribut von der Oberklasse Builder geerbt.

\paragraph{RepresenstationBuilder}
Die Klasse erstellt als konkreter Erbauer durch Aufrufen der Methode \textit{fetchBuildingBlock} aus einer Yaml-Datei einen RepresentationBlock und gibt ihn als Rückgabewert zurück. Die Verbindung zu der entsprechenden Yaml-Datei wird als Attribut von der Oberklasse Builder geerbt.
\paragraph{TableRepresenstationBuilder}
Die Klasse erstellt als konkreter Erbauer durch Aufrufen der Methode \textit{fetchBuildingBlock} aus einer Yaml-Datei einen TableRepresentationBlock und gibt ihn als Rückgabewert zurück. Die Verbindung zu der entsprechenden Yaml-Datei wird als Attribut von der Oberklasse Builder geerbt.
\paragraph{XYRepresenstationBuilder}
Die Klasse erstellt als konkreter Erbauer durch Aufrufen der Methode \textit{fetchBuildingBlock} aus einer Yaml-Datei einen XYRepresentationBlock und gibt ihn als Rückgabewert zurück. Die Verbindung zu der entsprechenden Yaml-Datei wird als Attribut von der Oberklasse Builder geerbt.
\paragraph{java.util.HashMap<K,V>}
TODO
\paragraph{SnakeYamlParser}
Diese Klasse stellt ein externes Paket dar, welches den SnakeYamlParser implementiert.

\clearpage
\subsection{Controller}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 14cm]{Grafiken/Controller_Struktur.png}
		\caption{Die Struktur des Controllers (Ausschnitt)}
		\label{Controller_Struktur}
	\end{center}
\end{figure}

Der Aufbau des Controllers setzt das Entwurfsmuster \textit{Kommando} (\textit{Command}) um. Die Rollen sind dabei folgendermaßen:

\begin{itemize}

\item Die Klasse \textit{CommandManager} erfüllt die Rolle des \textit{Aufrufers} (\textit{Invoker}).
\item Die Schnittstelle \textit{Command} erfüllt die Rolle eines \textit{Befehls} im abstrakten Sinne.
\item Die Klassen, welche \textit{Command} implementieren, erfüllen die Rolle der \textit{konkreten Befehle}.
\item Die Rolle des (bzw. der) \textit{Klienten} wird durch die Klassen \textit{ButtonAction}, \textit{BlockAction}, bzw. \textit{ConnectionAction} erfüllt. Diese bilden die Schnittstelle, über welche das \textit{View}-Modul auf den Controller zugreift.
\item Die Rolle der \textit{Empfänger} wird durch die Schnittstelle(n) zum \textit{Model}-Modul erfüllt.

\end{itemize}

\subsubsection{CommandManager}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 6cm]{Grafiken/CommandManager.png}
		\caption{Die Klasse CommandManager}
		\label{CommandManager}
	\end{center}
\end{figure}

Die Klasse CommandManager hat die Funktion, die Ausführung konkreter Befehle zu veranlassen. Der CommandManager ist als \textit{Singleton} definiert um sicherzustellen, dass von allen Klienten auf dieselbe Instanz zugegriffen wird.

Anhand eines \textit{Undo-} und eines \textit{Redo-Stacks} bietet der CommandManager außerdem die Möglichkeit an, bereits ausgeführte Befehle rückgängig zu machen (bzw. rückgängig gemachte Aktionen wiederherzustellen). Nicht alle Befehle können rückgängig gemacht werden.

\subsubsection{Command bzw. konkrete Befehle}

Die Schnittstelle Command und die konkreten Klassen, welche die Schnittstelle implementieren, sind die Befehle des Controllers. Jeder konkrete Befehl kapselt eine genau definierte Funktionalität. Weitere Befehle können problemlos hinzugefügt werden, ohne bestehende Klassen verändern zu müssen.

Bestimmte Befehle können durch \textit{unExecute()} rückgängig gemacht werden. In diesen Fällen wird durch \textit{isUndoable()} immer \textit{true} zurückgegeben.

Andere Befehle können nicht rückgängig gemacht werden. Dann ist die Methode \textit{unExecute()} leer und \textit{isUndoable()} gibt \textit{false} zurück.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 14cm]{Grafiken/Commands1.png}
		\caption{Baustein-Befehle}
		\label{Commands1}
	\end{center}
\end{figure}

\paragraph{AddBlockToConfigCommand}

Dieser Befehl fügt einen gegebenen Baustein zum Konfigurationsfeld hinzu.

\paragraph{RemoveBlockFromConfigCommand}

Dieser Befehl entfernt einen Baustein aus dem Konfigurationsfeld.

\paragraph{EditBlockPropertiesCommand}

Dieser Befehl verändert die Eigenschaften eines Bausteins.

\paragraph{CloneBlockCommand}

Dieser Befehl klont einen bestehenden Bausteinprototyp.

\paragraph{ExportBlockPrototypeCommand}

Dieser Befehl exportiert einen Bausteinprototypen als Datei.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 10cm]{Grafiken/Commands2.png}
		\caption{Verbindungs-Befehle}
		\label{Commands2}
	\end{center}
\end{figure}

\paragraph{CreateChannelConnectionCommand}

Dieser Befehl erstellt eine Verbindung zwischen zwei gegebenen Kanälen (welche wiederum zu Bausteinen gehören).

\paragraph{ModifyChannelConnectionCommand}

Dieser Befehl verändert Start- und/oder Endpunkt einer Verbindung zwischen zwei Kanälen.

\paragraph{DeleteChannelConnectionCommand}

Dieser Befehl löscht eine Verbindung zwischen zwei Kanälen.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 12cm]{Grafiken/Commands3.png}
		\caption{Messlauf-Befehle}
		\label{Commands3}
	\end{center}
\end{figure}

\paragraph{StartRunCommand}

Dieser Befehl startet einen Messlauf.

\paragraph{StopRunCommand}

Dieser Befehl beendet einen aktiven Messlauf.

\paragraph{PauseRunCommand}

Dieser Befehl pausiert einen aktiven Messlauf.

\paragraph{ResumeRunCommand}

Dieser Befehl setzt einen pausierten Messlauf fort.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 10cm]{Grafiken/Commands4.png}
		\caption{Messkonfigurations-Befehle}
		\label{Commands4}
	\end{center}
\end{figure}

\paragraph{SaveConfigCommand}

Dieser Befehl speichert die aktuelle Messkonfiguration an einem übergebenen Dateipfad.

\paragraph{LoadConfigCommand}

Dieser Befehl lädt eine Messkonfiguration von einem angegebenen Pfad.

\paragraph{ResetConfigCommand}

Dieser Befehl entfernt alle Elemente aus dem Konfigurationsfeld. (Verwendung optional.)

\subsubsection{Verbindung zum View}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 14cm]{Grafiken/View_Controller_Interface.png}
		\caption{Schnittstellenimplementierung View zu Controller}
		\label{View_Controller_Interface}
	\end{center}
\end{figure}

Durch das View-Modul werden mehrere Schnittstellen definiert.

\paragraph{BlockAction} Die Klasse BlockAction implementiert die Schnittstelle IBlockAction des Views.

\paragraph{ButtonAction} Die Klasse ButtonAction implementiert die Schnittstelle IButtonAction des Views.

\paragraph{ConnectionAction} Die Klasse ConnectionAction implementiert die Schnittstelle IConnectionAction des Views.

\subsubsection{Verbindung zum Model}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 14cm]{Grafiken/Controller_Model_Interface.png}
		\caption{Schnittstelle Controller zu Model}
		\label{Controller_Model_Interface}
	\end{center}
\end{figure}

Es werden Schnittstellen vorgegeben, die durch das Model-Modul implementiert werden.

\paragraph{IModelInformation}

Diese Schnittstelle stellt Methoden zur Verfügung, anhand derer die Messkonfiguration und darin enthaltene Bausteine verändert werden können.

\paragraph{IMeasurementRun}

Diese Schnittstelle stellt Methoden zur Verfügung, anhand derer ein Messlauf gestartet, beendet, angehalten und fortgeführt werden kann.

\clearpage
\subsection{View}
Das Paket View, stellt gemäß des MVC- Entwurfmusters die Darstellungen des Modells dar und realisiert Benutzerinteraktionen auf der graphischen Benutzeroberfläche. 

\subsubsection{MainWindow} 
Die Klasse MainWindow stellt den Rahmen der Benutzeroberfläche dar. Alle Restlichen graphischen Oberflächen werden durch das MainWindow instanziert. Dazu gehört das Konfigurationsfeld, Buttonmenü, Konfigurationsbausteinmenü, Hilfe , Optionen und Fehlerfenster. 
Da MainWindow, dass Entwurfsmuster Singleton verwendet, kann die Anwendung nur ein MainWindow besitzen soll.
Bei Schließen des MainWindow wird ebenso die gesamte Anwendung beendet.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 5cm]{Grafiken/MainWindow.png}
		\caption{Die Klasse MainWindow}
		\label{Entwurf_Grob}
	\end{center}
\end{figure}

\newpage

\subsubsection{Menues}

Menüs bieten dem Benutzer eine übersichtliche visuelle Zusammenfassung der Darstellungen der konkreten Bausteine und Knöpfe. 

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 14cm]{Grafiken/MenuesNamespace.png}
		\caption{Aufbau des Menü-Paket}
		\label{Entwurf_Grob}
	\end{center}
\end{figure}

\paragraph{PrototypeField}
Die Klasse PrototypeField ist die Über-Klasse zu SensorBlockField, TransformationBlockField und RepresentationBlockField. 
Sie stellt die Menüfläche dar, in welcher vordefinierte Konfigurationsbausteine je nach Kategorie dargestellt werden und der Benutzer sie mit dem Mauszeiger in das Konfigurationsfeld ziehen und damit positionieren kann. Diese vordefinierten Bausteine werden über das Backend eingelesen und werden über das Model im Directory zur Verwendung auf der Benutzeroberfläche bereitgestellt.

\paragraph{FieldHandler}
Das Interface FieldHandler nimmt Benutzereingaben entgegen, in diesem Fall werden das Öffnen der Menüflächen registiert und an das Feld weitergeleitet.

\paragraph{SensorBlockField}
Die Klasse SensorBlockField stellt die Menüfläche dar, in welcher alle Sensorbausteine angezeigt werden.

\paragraph{TransformationBlockField}
Die Klasse TransformationBlockField stellt die Menüfläche dar, in welcher alle Transformationsbausteine angezeigt werden.

\paragraph{RepresentationBlockField}
Die Klasse RepresentationBlockField stellt die Menüfläche dar, in welcher alle Representationsbausteine angezeigt werden.

\paragraph{ButtonField}
Die Klasse ButtonField stellt die Menüfläche dar, in welcher alle konkreten Knöpfe platziert sind und diese für den Benutzer verwendbar sind.

\subsubsection{Configuration}

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 14cm]{Grafiken/ConfigurationNamespace.png}
		\caption{Aufbau des Konfigurations Paket}
		\label{Entwurf_Grob}
	\end{center}
\end{figure}


\paragraph{ConfigurationField}
Die Klasse KonfigurationField stellt das Konfigurationfeld dar, in welchem der Benutzer eine Messkonfiguration aufbauen kann.
Konfigurationsbausteine, welche der Benutzer in das Konfigurationsfeld platziert werden in einer Liste gespeichert. 
Konfigurationsbausteine, welche der Benutzer aus dem Konfigurationsfeld entfernt, werden aus der Liste gelöscht
Beim Platzieren der Konfigurationsbausteine in das Konfigurationsfeld wird dem Konfigurationsbaustein eine eindeutige Position zugeteilt, welche in Form von einer x-Koordinate und einer y-Koordinate dargestellt wird.
Die Liste der Bausteine kann ebenfalls von außerhalb ausgelesen oder gesetzt werden, falls z.B die Anordnung der Bausteine und Verbindungen gespeichert oder gesetzt werden soll.

\paragraph{BuildingBlockView}
Die Klasse BuildingBlockView ist die Überklasse der Darstellungen der Konfigurationsbausteine.
Bausteine werden über das Directory erzeugt, indem zu jedem im Directory gespeicherten Baustein eine Darstellung dieses Bausteins erzeugt wird. Name und InitId bleiben bei Erzeugung des Bausteins gleich, jedoch wird der Baustein, um die visuellen Komponenten Koordinaten, Farbe, Form und Größe erweitert.
Konfigurationsbausteine besitzen eine eindeutige Initialisierungs-ID, darunter versteht man die ID, welche der Baustein beim Erstellen durch das Model bekommt. Jede konkrete Instanz dieses Baustein besitzt diese Initialsierungs-ID (InitId). Wenn ein Baustein mehrfach durch den Benutzer in das Konfigurationsfeld gezogen wird, könnte dies dazu führen, dass diese Initialisierungs-ID nicht mehr eindeutig für diesen Baustein wäre. Deswegen besitzt jeder im Konfigurationsfeld platzierte Baustein eine Konfigurations-ID. Diese ID ist eindeutig für diesen Baustein und somit ist dieser Baustein unterscheidbar von weiteren Bausteinen gleichem Prototyps. Ebenfalls besitzt ein Baustein einen Namen und falls sie im Konfigurationsfeld platziert werden ihre Position anhand der Koordinaten x und y. Form, Farbe und Größe sind ebenfalls festgelegt.  
Bausteine werden über das Directory erzeugt, indem zu jedem im Directory gespeicherten Baustein eine Darstellung dieses Bausteins erzeugt wird. Name und ID bleiben bei Erzeugung des Bausteins gleich, jedoch wird der Baustein, um die visuellen Komponenten Koordinaten, Farbe, Form erweitert.

\paragraph{SensorBlockView}
Die Klasse SensorBlockView stellt einen Sensorbaustein dar. 
Sensorbausteine, welche in dem Konfigurationsfeld platziert werden, können mit anderen Bausteinen verbunden werden, was im Messlauf einen Datenfluss über die verbundenen Bausteine erlaubt. Sensorbausteine besitzen, im Gegensatz zu anderen Konfigurationsbausteinen nur Datenausgänge, über welche sie verbunden werden können, da Sensoren, gemäß physikalischer 
Repräsentation nur Datenausgänge besitzen.

\paragraph{TransformationBlockView}
Die Klasse TransformationBlockView stellt einen Transformationsbaustein dar. Transformationsbausteine besitzen eine vordefinierte Funktion, welche die Messdaten nach der Funktion transformiert. Transformationbausteinen besitzen Eingänge, welche Daten von Sensorenbausteinen oder anderen Transformationenbausteine empfangen können. Ausgänge der Transformationsbausteine können nur an weitere Transformationsbausteine oder Darstellungsbausteine angebunden werden, um einen sinnvollen Datenfluss zu ermöglichen.

\paragraph{RepresentationBlockView} 

Die Klasse RepresentationBlockView stellt einen Darstellungbaustein dar, dieser bestimmt, wie die Messdaten visualisiert werden. Dafür bekommt der Repräsentationsbaustein die visuelle Darstellung in dem Darstellungsgerüst (z.B: Graph, Tabelle) mit den dargestellten Messdaten.
Zur Speicherung der visuellen Darstellung der Daten muss ein Bild erstellt werden, welches zum Speichern weiter geleitet wird.
Darstellungsbausteine besitzen nur Eingänge, da dargestellt Messdaten nicht mehr verarbeitet werden. 

\paragraph{IDragAndDropHandler}

\paragraph{HelpDecorator}

\paragraph{HelpDecoratorHandler}

\paragraph{ChannelDecorator}

\paragraph{InChannelDecorator}

\paragraph{OutChannelDecorator}

\paragraph{Wire}

\paragraph{AddWireDragAndDropHandler}

\paragraph{RemoveWireDragAndDropHandler}


\newpage 

\subsubsection{BuildingBlockProperties}

Damit Benutzer Informationen über einzelne Bausteine bekommt, welche ihm das Benutzen der Anwendung erleichtern würden, wie auch eine tiefere Einsicht über die Funktionsweise bietet, stellt jeder Baustein ein eigenes "Eigenschaften-Menü" bereit, in welchem dem Benutzer die wichtigsten Eigenschaften zu sehen bekommt.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 14cm]{Grafiken/BuildingBlockPropertiesNamespace.png}
		\caption{Aufbau des BuildingBlockProperties-Paket}
		\label{Entwurf_Grob}
	\end{center}
\end{figure}

\paragraph{BuildingBlockProperties}

Die abstrakte Klasse BuildingBlockProperties stellt alle Eigenschaften der konkreten Bausteine dar, welche alle Arten von Bausteinen (Sensor, Transformation, Darstellung) gemeinsam haben. Dazu gehören der Name,  Initialisierungs-ID, eindeutige Konfigurations-ID, Farbe, Form und Größe. Da einzelne Eigenschaften unveränderlich sein sollen, wie die IDs lassen sich nur Name, Farbe, Form und Größe verändern.

\paragraph{SensorBlockProperties}

Neben den gemeinsamen Eigenschaften besitzt die Unterklasse SensorBlockProperties ebenfalls das Attribut der Dimension, welches darstellt über wie viele Kanäle dieser Sensor Messdaten liefert. Da dieses Attribut für Sensoren unveränderlich ist, kann diese ebenfalls vom Benutzer nicht verändert werden.

\paragraph{TransformationBlockProperties}

Transformationsbausteine besitzen neben den Standart-Eigenschaften noch eine vordefinierte Funktion für jeden Transformationsbaustein. Um dem Benutzer zu erlauben neue Transformationsbausteine zu definieren ist die Funktion veränderbar.

\paragraph{RepresentationBlockProperties}

Da Repräsentatonsbausteine die visuelle Repräsentation beschreiben besitzen diese für die Darstellung notwendige Eigenschaften, wie Einheit, Maximalwerte der Achsen und Art der Darstellung. Um den Benutzer die Möglichkeit zu geben die Darstellung auf die Messwerte anzupassen, lassen sich Einheit und Maximalwerte vom Benutzer einstellen.

\paragraph{BuildingBlockPropertiesHandler}

Damit der Benutzer Attribute der Konfigurationsbausteine ändern kann, bietet der BuildingBlockPropertiesHandler Methoden an, um die gemeinsamen Attribute, wie Name, Farbe, Form, Größe zu verändern. Das heißt, er nimmt diese Benutzereingaben entgegen.

\paragraph{TransBlockPropertiesHandler}

Da der Benutzer bei einem Transformationsbaustein nur die Funktion verändern kann nimmt dieser Handler ebenfalls nur eine Benutzereingabe für eine Funktion entgegen und setzt diese in den Transformationsbaustein-Eigenschaften.

\paragraph{ReprBlockPropertiesHandler}

Bei Representationsbaustein-Eigenschaften ist der Benutzer in der Lage Einheit und Grenzwerte zu setzten. Daher nimmt der Handler diese Benutzer eingaben entgegen.


\newpage

\subsubsection{Button}

Knöpfe bieten dem Benutzer eine Anzahl von Funktion zur Bedienung der Anwendung an. Das Paket ButtonLayer enthält die unterschiedlichen Knöpfe, das Feld, in welchem die Knöpfe dargestellt werden und eine Annahmestelle für die Benutzerinteraktion.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 14cm]{Grafiken/ButtonNamespace.png}
		\caption{Aufbau des Button-Paket}
		\label{Entwurf_Grob}
	\end{center}
\end{figure}

\paragraph{Button}

Die Klasse Button ist die Überklasse zu den konkreten Knöpfen. Jeder Knopf enthält einen eindeutigen Namen und zur Unterscheidung der Knöpfe und zur einfachen Benutzung eine Farbe und ein aussagekräftiges Bild, welches die Funktionalität des Knopfes darstellt.

\paragraph{StartButton}

Die Klasse StartButton erbt von der Überklasse Button und stellt den Knopf dar, welcher bei Betätigung den Messlauf starten soll.

\paragraph{PauseButton}

Die Klasse PauseButton ist eine weitere Konkretisierung von Button und stellt den Knopf dar, welcher einen Messlauf pausiert.

\paragraph{ResumeButton}

Die Klasse ResumeButton stellt den Knopf dar, welcher einen Messlauf fortsetzt.

\paragraph{ResetButton}

Die Klasse ResetButton stellt den Knopf dar, welcher bei Betätigung den Messlauf auf den Ausgangszustand zurücksetzt.

\paragraph{SaveDataButton}

Die Klasse SaveDataButton stellt den Knopf dar, welcher dem Benutzer ermöglicht die Messwerte aus einem Messlauf zu speichern.

\paragraph{SaveRepresentationButton}

Die Klasse SaveRepresentationButton stellt den Knopf dar, welcher eine Momentaufnahme der graphischen Visualisierung der Messwerte speichern lässt.

\paragraph{SaveConfiguration}

Die Klasse SaveConfiguration stellt den Knopf dar, welcher dem Benutzer erlaubt seine eigene Messkonfiguration zu speichern.

\paragraph{LoadConfiguration} 

Die Klasse LoadConfiguration repräsentiert den Knopf, welcher eine gespeicherte Messkonfiguration in das Konfigurationsfeld laden lässt.

\paragraph{NewConfiguration}

Die Klasse NewConfiguration stellt den Knopf dar, welcher dem Benutzer die Funktion bietet eine neue Konfiguration zu erstellen.

\paragraph{UndoButton}

Die Klasse UndoButton stellt den Undo-Knopf dar, welcher bei Betätigung die letzte Benutzeraktion rückgängig macht.

\paragraph{RedoButton}

Die Klasse RedoButton stellt den Redo-Knopf dar, welcher die letzte rückgängig gemachte Aktion wiederherstellt.

\paragraph{Interface ButtonHandler}

Das Interface ButtonHandler registriert Benutzerinteraktionen auf der Benutzeroberfläche und löst die Methode ButtonPressed() aus, über welche die Anwendung die Benutzerinteraktion weiterverarbeitet.

\subsubsection{OptionAndHelp}

Das Paket OptionAndHelp soll dem Benutzer die Benutzung der Anwendung vereinfachen. Getrennt wurde das Paket in die Funktionsspezifische Klasse HelpWindow, welche dem Benutzer Hilfe zur Bedienung gibt und in die Klasse OptionsWindow, welche dem Benutzer Auswahlmöglichkeiten gibt, um eine möglichst Barrierefreie Benutzung zu ermöglichen.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 14cm]{Grafiken/HelpAndOptionNamespace.png}
		\caption{Aufbau des HelpAndOption-Paket}
		\label{Entwurf_Grob}
	\end{center}
\end{figure}

\paragraph{HelpWindow}

Die Klasse HelpWindow beschreibt das Hilfe-Fenster der Anwendung. Der Benutzer bekommt bei Öffnen des Hilfe-Fensters eine allgemeine Erklärung zur Funktionalität und zur Bedienbarkeit der gesamten Anwendung. Ebenfalls könnte in dem Hilfstext ein einfaches Anwendungsbeispiel erklärt werden, um dem Benutzer erste Schritte zu vereinfachen.

\paragraph{OptionsWindow}

Die Klasse OptionsWindow stellt das Einstellungen-Fenster der Anwendung dar. Der Benutzer soll hierbei das verwendete Farbschema ändern können, um die Bedienung der Anwendung trotz möglichen Farbschwächen zu ermöglichen. Ebenfalls soll die Schriftgröße der Textelemente verändert werden können, um Sehschwächen auszugleichen. 

\newpage

\subsubsection{Exception}

Fehlernachrichten sind ein wichtiger Teil der Anwendung, um dem Benutzer eine möglichst benutzerfreundliche Umgebung zu liefern und eine möglichst einfache und verständliche Bedienung zu ermöglichen. Damit der Benutzer aussagekräftige Fehlermeldungen erhält unterscheiden wir im Entwurf zwischen drei Typen von Fehlerarten aus verschiedenen Fehlerquellen.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 14cm]{Grafiken/ExceptionNamespace.png}
		\caption{Aufbau des Exception-Paket}
		\label{Entwurf_Grob}
	\end{center}
\end{figure}

\paragraph{ExceptionWindow}

Die Klasse ExceptionWindow stellt die Überklasse der drei verschiedenen Unterklassen dar und enthält die gemeinsamen Attribute, welche die konkreten Fehlermeldungen enthalten. Eine Fehlermeldung besitzt immer eine Titel, der wünschenswerter Weise bereits die Fehlermeldung aussagekräftig und kurz beschreibt. Die Beschreibung der Fehlermeldung wiederum liefert eine genauere und explizite Erklärung zur Fehlerquelle, Fehlerursache und möglicherweise ebenfalls zur Fehlerbehebung.
Damit der Benutzer auf die Fehlernachricht aufmerksam wird, bewirkt die Methode popUp(), dass die Fehlernachricht zu sehen ist. Damit der Benutzer weiterarbeiten kann oder den Fehler beheben will kann die Fehlernachricht wieder geschlossen werden.

\paragraph{BuildingBlockExceptionWindow}

Die Klasse BuildingBlockExceptionWindow ist eine Konkretisierung der Überklasse ExceptionWindow und stellt eine Fehlernachricht im Bezug zu Konfigurationsbausteinen dar. Neben einem Titel und einer Beschreibung wird zur Erzeugung dieser Fehlernachricht die eindeutige ID des Konfigurationsbausteins benötigt. Dadurch erfährt der Benutzer sofort, bei welchem Konfigurationsbaustein ein Fehler aufgetreten ist. Die Methode popUp() aus der Überklasse wird hier überschrieben. Damit soll bewirkt werden, dass die Fehlermeldung als Pop-Up Nachricht direkt neben dem Konfigurationsbaustein im Konfigurationsfeld erscheint und somit dem Benutzer sofort die Fehlerquelle signalisiert. Ebenfalls wird zur Darstellung des Fehlers die Farbe des Konfigurationsbaustein im Konfigurationsfeld geändert, um dem Benutzer nochmal auf die Fehlerquelle hinzuweisen.

\paragraph{ConnectionExceptionWindow}

Die Klasse ConnectionExceptionWindow ist eine weitere Konkretisierung der Überklasse ExceptionWindow und stellt eine Fehlernachricht bei Verbindungen zwischen Konfigurationsbausteinen dar. Zur Identifizierung der Fehlerquelle wird neben Titel und Beschreibung ebenfalls die IDs der Ein- und Ausgangskanäle der Konfigurationsbaustein mit übergeben. Die Methode popUp() soll ebenfalls die Fehlernachricht in der Nähe der Fehlerquelle im Konfigurationsfeld plazieren. Ebenfalls wird die Farbe des Drahtes sinnvoll verändert um die Fehlerquelle zu signalisieren.

\paragraph{GeneralExceptionWindow}

Die Klasse GeneralExceptionWindow stellt neben den zwei konkreten Fehlermeldungen ConnectionExceptionWindow und BuildingBlockExceptionWindow eine allgemeinere Fehlernachricht dar. Diese werden zum Beispiel bei Messfehlern oder Fehler bei der Messkonfiguration ausgelöst. Diese Fehlernachrichten sollen sichtbar in der Mitte der Anwedung geöffnet werden, um dem Benutzer auf diesen Fehler hinzuweisen. 

\paragraph{ExceptionWindowManager}

Die Klasse ExceptionWindowManager nimmt Fehlermeldungen entgegen und stößt die Visualisierung der jeweilig nach Fehlermeldung unterschiedlichen Fenster an. Der Klasse werden die für eine Fehlermeldung notwendigen Parameter Titel und  Beschreibung übergeben. Je nach Art der Fehlermeldung wird auch die Baustein- oder Verbindung-ID der Fehlerquelle übergeben.

\subsubsection {FacadeModelView}

Das Paket FacadeModelView enthält das Interface, welches das Model anbietet und vom View verwendet wird. Da durch das Directory eine Art Zwischenschicht zwischen Model und View darstellt ersetzt die Fassade zum Directory eine unübersichtliche Fassade zu dem Model. 

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 12 cm]{Grafiken/FacadeModelViewNamespace.png}
		\caption{Aufbau des FacadeModelView-Paket}
		\label{Entwurf_Grob}
	\end{center}
\end{figure}

\paragraph{ViewDirectoryInterface}

Das Interface ViewDirectoryInterface bietet wichtige Funktionen an, um Änderungen am Model in die GUI zu übertragen. 
Bei dem Starten der Anwendung werden alle über das Backend übertragenen Bausteine durch das Model in das Directory geladen. Um alle Bausteine in die GUI zu laden gibt die Methode getFullInitBlock() die gesamte Hash-Map, welche die Konfigurationsbausteinen enthält zurück um daraus die Prototypenmenüs zu erstellen. Um einzelne Bausteine mit bestmmter aus dem Directory zu laden gibt es die Methoden getInitBuildingBlock() und getConfigBuildingBlock(). Um eine gespeicherte Verbindung zu bekommen gibt es die Methode getConnection(chId1: int, chId2: int), welche zwei ChannelDecorater-IDs mit übergibt und die Verbindung zurückgibt.
Damit das View bei Benachrichtigung über ein Update des Models überprüfen kann, ob das Directory Änderungen enthält gibt es die Methode checkForUpdates(), welche einen Wahrheitswert zurückgibt, welcher eine Aussage über die Änderungen am Directory enthält.

\subsubsection{FacadeControllerView}

Das Paket FacadeControllerView stellt die Schnittstelle dar, welche der Controller anbietet und vom View benutzt wird. Zur Übersicht ist die Fassade intern in 3 Interfaces aufgeteilt, welche jeweils Funktionen eines Objektes darstellen (Button, Block, Connection). Eine PickUp-Klasse stellt die Anbindung zum View dar und Kapselt die Interfaces.

\begin{figure}[htbp]
	\begin{center}
		\includegraphics[width = 14 cm]{Grafiken/FacadeControllerViewNamespace.png}
		\caption{Aufbau des FacadeControllerView-Paket}
		\label{Entwurf_Grob}
	\end{center}
\end{figure}

\paragraph{PickUpPointControllerView}

Die Klasse PickUpPointControllerView stellt die Schnittstelle zwischen den Interfaces und den Klassen, welche auf diese zugreifen dar. Ihre Methoden liefern jeweils das gewollte Interface zurück, über welches dann Aktionen an den Controller übergeben werden können.

\paragraph{IButtonAction}

Das Interface IButtonAction liefert eine Schnittstelle für alle Knopf-Aktionen. Dass heißt, wenn durch den ButtonHandler eine Benutzereingabe in Form des Drücken eines konkreten Knopfes registriert wird, wird in diesem Interface die für den Knopf spezifische Methode aufgerufen, um den Controller zu benachrichtigen. Dabei gibt es für jeden konkreten Knopf eine Interface-methode.

\paragraph{IBlockAction}

Das Interface IBlockAction liefert eine Schnittstelle für alle Benutzerinteraktionen mit einem Konfigurationsbaustein. Diese gibt das Interface weiter an den Controller, in dem das Interface implementiert ist. Die Methode blockPlaced gibt hierbei weiter, wenn ein Konfigurationsbaustein aus einem dem Prototypen Menüs auf das Konfigurationsfeld per Drag-and-Drap platziert wurde. Hierbei wird die Prototyp-spezifische ID mitgegeben und die Koordinaten, welche die Position des Bausteins eindeutig bestimmen. Die Methode blockMoved wird dann benutzt, wenn ein Konfigurationsbaustein innerhalb des Konfigurationsfeldes die Position ändert. Wenn der Benutzer einen Konfigurationsbaustein aus dem Konfiguratonsfeld entfernt wird dies über die Methode blockRemoved mit Übergabe der eindeutigen ID an den Controller überliefert. Wenn der Benutzer die Eigenschaften eines Bausteinprototyps ändert wird dies über die Methode editBuildingBlockProperties mit der eindeutigen ID und den neuen Eigenschaften übergeben. Wenn ein Baustein geklont oder exportiert werden soll, wird dies mit der Übergabe der eindeutigen ID an den Controller übergeben.

\paragraph{IConnectionAction}

Das Interface IConnectionAction liefert eine Schnittstelle für Aktionen, welche der Benutzer mit Verbindungen macht. 
Die Methode connectionAdded übergibt dem Controller zwei eindeutige Channel-IDs, welche der Benutzer miteinander verbunden hat, um eine Messkonfiguration aufzubauen.
Wenn der Benutzer eine Verbindung zwischen zwei Konfigurationsbausteinen entfernt übergibt die Methode connectionRemoved die zwei Channel-IDs an den Controller um diese Verbindung aus der Messkonfiguration zu entfernen.
Falls der Benutzer einen Konfigurationsbaustein entfernt, welcher bereits mit weiteren Konfigurationsbausteinen verbunden war, werden diese Verbindungen ebenfalls gelöscht, daher wird bei der Methode blockAndChannelsRemoved nur die eindeutige Konfigurationsblock-ID übergeben.

\clearpage
\section{Sequenzdiagramme}


\clearpage
\section{Änderungen am Pflichtenheft}


\clearpage
\section{Formale Spezifikationen von Kernkomponenten}

\clearpage
\section{Weitere UML Diagramme}


\clearpage
\section{Anhang}


\clearpage
\subsection{Vollständiges Klassendiagramm}


\clearpage
\section{Glossar}\label{glossar}

\renewcommand*{\glossarysection}[2][]{}	% prevents double glossary section heading
\printnoidxglossaries				% generate pdf twice when adding new entries


\end{document}\grid
