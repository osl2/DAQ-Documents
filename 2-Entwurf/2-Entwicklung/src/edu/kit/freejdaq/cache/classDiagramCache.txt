@startuml
namespace Cache {

class MStreamListener {
	+ receiveMDataSet(channelId: String, timeStamp: long, value: double): void
	+ connectionTerminated(): void
}


class MRunTiming {
	- replayTimePointer: long
	- period: long
	+ MRunTiming(initData: MRunInfo)
	- createCache(): Cache
	- addBufferForOneSensorInChannel(SensorId: String)
	- addCheckAndNotifyAction(action: CheckAndNotifyAction): void
	+ getMStreamListener(): MStremListener
	..
	+ addMRunListener(listener: IMRunListener)
	+ startRepeatedTimer(): void
	+ stopRepeatedTimer(): void
	..
	+ run(): void
	- setCurrentTime(): void
	- checkActions(): void
}

class Timer {
	-period: long
	+schedule(timerTask: TimerTask, period: long)
	+cancel(): boolean
}

class Cache{
	+ addBufferForOneSensorInChannel(SensorId: String)
	+ receiveMDataSet(channelId: String, timeStamp: long, value: double): void
	+ isCompletePackageSetAvailable(from: long, to: long): boolean
	+ pollCompletePackageSet(from: long, to: long):  IdValuePair[]
}

class BufferForOneSensorInChannel {
	-sensorInChannelId: String
	-buffer: Queue<TimestampValuePair>
	+getInChannelId(): String
	+addPacket(timeStamp: long, value: double)
	+getAllPacketsDuringTimespan(from: long, to: long): double[]
}

class TimestampValuePair	{
	-value: double
	-timeStamp: long
	+TimestampValuePair(value: double, timeStamp: long)
	+getValue(): double
	+getTimeSpamp(): long
}
	
class ConnectionTerminatedAction {
	-
	+ connectionTerminated(): void
	+ checkAndNotify(replayTimepointer: long, mRunForward: MRunForward): long
}

class TimeoutAction {
	- numberToleratedPeriods: int
	- 
	+ TimeoutAction(numberToleratedPeriods: int)
	+ checkAndNotify(replayTimepointer: long, mRunForward: MRunForward): long
}

class ErrorCodeAction {

	+addCodes(sensorInChannelId: String, codes: double[])
	+checkAndNotify(replayTimepointer: long, mRunForward: MRunForward): long
}

class DataSetCompleteAction {
	+checkAndNotify(replayTimepointer: long, mRunForward: MRunForward): long
}

class EnhancedValuePacket {
	-sensorInChannelId: String
	-value: double
	-timeStamp: long
	+TimestampValuePair(sensorInChannelId: String, value: double, timeStamp: long)
	+getSensorInChannelId(): String
	+getValue(): double
	+getTimeSpamp(): long
}
	
class ErrorCodesForInChannel {
	sensorInChannelId: String
	errorCodes: double[]
}
MStreamListener --> ConnectionTerminatedAction
MStreamListener --> Cache
ConnectionTerminatedAction .up.|> CheckAndNotifyAction
TimeoutAction .up.|> CheckAndNotifyAction
ErrorCodeAction .up.|> CheckAndNotifyAction
DataSetCompleteAction .up.|> CheckAndNotifyAction

MRunTiming -right-> Timer
MRunTiming .right.|> TimerTask
Timer -down-> "1" TimerTask
MRunTiming ..> MStreamListener
Cache .right.> EnhancedValuePacket
Cache --> "*" BufferForOneSensorInChannel

BufferForOneSensorInChannel .right.> TimestampValuePair
MRunTiming --> "*" CheckAndNotifyAction

DataSetCompleteAction --> Cache
ErrorCodeAction --> Cache
ErrorCodeAction -down-> "*" ErrorCodesForInChannel

MRunTiming --> "*" IMRunListener
MRunTiming ..> IMRunInfo

interface CheckAndNotifyAction {
	+checkAndNotify(replayTimepointer: long, mRunForward: MRunForward): long
}

interface IMRunListener {
	+justWaiting():  void
	+indicateError(inChannelId: String, errorCode: double)
	+indicateTimeout(): void
	+indicateConnectionTerminated(): void
	+dispatchCompletePacketSet(completePacketSet: EnhancedValuePacket[])
}

interface IMRunInfo {
	+getAllInChannelIds(): String[]
	+getErrorCodes(inChannelId: String): double[]
	+getPeriod(): long
	+getTimeoutOption(): long
}

interface TimerTask {
	+run(): void
}

IMRunListener <|.. Model.MRunReaction
IMRunInfo <|.. Model.MRunInfo

}
@enduml
