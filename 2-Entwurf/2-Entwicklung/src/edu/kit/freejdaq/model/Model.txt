@startuml






namespace Model {







	class MeasurementRun {

		+start(): boolean
		+pause(): boolean
		+resume(): boolean
		+reset(): boolean
		+setUpdateRate(MeasurementConfiguration config): boolean

	}

	enum MesurementRunState{
		INITIAL_STATE
		RUNNING
		PAUSED
	}
	MeasurementRun -> MesurementRunState



	class MeasurementConfiguration{
		-pathToFile: String
		-updateRate: float
		-listOfAllChannels: <Channel>
		-configurationAdjacencyList: configuration[]
		+getPathToFile(): String

 		+getMeasurementConfig(): MeasurementConfiguration
 		+addBuildingBlock(id: String)
		+removeBuildingBlock(id: String)
		+addConnection(firstChannelId: String, secondChannelId: String)
		+removeConnection(firstChannelId: String, secondChannelId: String)

 		+createModelFromYamlDom(modelDom: YamlDom): String

	}
	MeasurementConfiguration "1" -- "*" MeasurementRun


	'----------------------------------------------------------------------------------------
	'PrototypCollection: List of all predefined and custom BuildingBlocks
	'----------------------------------------------------------------------------------------

	class PrototypCollection{
		 +clonePrototyp(id: String)
		 +returnCloneOfBlock(BuildingBlock: block)
		 +editPropertyOfPrototyp(key: String, value: Integer)
	}


	abstract class BuildingBlock
	{

		-id: String
		-name: String
		-userInfo: String
		+setId()
		+addInChannel(id: String, name: String): void
		+addOutChannel(id: String, name: String): void
		+removeInChannel(id: String, name: String): void
		+removeOutChannel(id: String, name: String): void



	}


	MeasurementConfiguration "1" -- "*" BuildingBlock

	PrototypCollection "1" -- "*" BuildingBlock


	namespace TransformationLogic {
		abstract class Transformation {
			+<<create>> Transformation()
			+<<create>> Transformation(Yaml inputTransformationYaml)
			+setFunction(String inputFunction)
			+{abstract} applyFunction(): Integer
		}
		class Function {
			<<create>>Function(String inputFunction) : Function
			+applyFunction(Integer data)
		}
		Function "1" - "*" Transformation
	}


	BuildingBlock <|-  Model.TransformationLogic.Transformation
	'----------------------------------------------------------------------------------------
	'Note: The manager aspect of this diagramm can be found, in more detail, at another place.
	'It stands here for a complete overview
	'----------------------------------------------------------------------------------------
	'package kit.edu.freejdaq.configurationBlockManager {
	'	abstract class ConfigurationBlockManager{
	'		listOfBlocks : ConfigurationBlock[]
	'		{abstract}+add(BuildingBlock block): boolean
	'		{abstract}+remove(BuildingBlock block): boolean
	'		{abstract}+showAllBocks(BuildingBlock block): boolean
	'	}
	'
	'	class RepresentationManager {
	'
	'
	'	}
	'
	'}

	namespace RepresentationLogic {

		abstract class Representation{

			{abstract} processValue()


			}

		class TableRespresentation {
			processValue()

		}


		class XYRepresentation {
			processValue()
			traceName: String
			title: String
			xAxisName: String
			yXisName: String
			hasToolBar: boolean


		}

		note right of  Model.RepresentationLogic.XYRepresentation
	  		use eclipse nebula
	  		for display
		end note
		XYRepresentation -up-|> Representation
		TableRespresentation   -down-|> Representation


	}
	BuildingBlock <|--  Model.RepresentationLogic.Representation

	namespace SensorLogic {

		abstract class Sensor{
			´{abstract} processValue()

			}

		 class PhysicalSensor{
		 	processValue()
		 }
		 class VirtualSensor{
		 	processValue()
		 }
		 VirtualSensor --|> Sensor
		 PhysicalSensor --|> Sensor
	}
	BuildingBlock <|-- Model.SensorLogic.Sensor


	namespace ChannelLogic {

	class Channel {
		-id: String
		-value: int
		+ establishConnection(String targetChannelId)
		+ receiveValue()
		+ connect(): void
		+ unConnect(): void
		+ receiveValue(): void
		+ eraseValue(): void
		+ {abstract} forwardValue(): void

	}
	Channel ..|> IValueHandler

	note top of Channel
	  first part of channelId is
	  the corresponding buildingBlockId
	end note

	abstract class ChannelState {
		+ {abstract} establishConnection(String targetChannelId)
		+ {abstract} receiveValue()
	}
	Channel --> ChannelState
	note right of ChannelState
	  Schablonenmethode um Unterschiede zwischen
	  In und Out Channeln zu überbrücken
	end note
	class Connected{
		+ establishConnection(String targetChannelId)
		+ receiveValue()
	}
	Connected --|> ChannelState
	class UnConnected{
		+ establishConnection(String targetChannelId)
		+ receiveValue()
	}
	UnConnected --|> ChannelState
	class ValueReady{
		+ establishConnection(String targetChannelId)
		+ receiveValue()
	}
	ValueReady --|> ChannelState
	class InChannel{
		-varName: String
		+forwardValue(): void
	}

	InChannel --|> Channel

	class OutChannel{
		-channelName: String
		+forwardValue(): void
	}

	class MRunInfo {
	+getAllInChannelIds(): String[]
	+getErrorCodes(inChannelId: String): double[]
	+getTimeoutOption(): long
	}



	OutChannel --|> Channel
	OutChannel "1" -- "1" InChannel
	note top of OutChannel
	  forwardValue wird bei
	  receive Value aufgerufen.
	  Hier ausimplementiert.
	end note

	note left of OutChannel
	  channelName steht für Funktionsnamen
	   bei Trafos und für
	   Channelname bei Sensoren
	end note




	interface IValueHandler {

		processValue()
	}

	note right of IValueHandler
	  interface to provide
	  Data to a channel
	end note


	}

	BuildingBlock "1" --> "*" Model.ChannelLogic.InChannel
	BuildingBlock "1" --> "*" Model.ChannelLogic.OutChannel

	class HelpMessage{
		- messageFileName : String
		+ HelpMessage(msgFile : String)
		+ displayMessage() : void
	}
	note right of HelpMessage : "messageFileName" leads to [html/markdown/?] \nfile containing message text, \nwhich can be displayed by the application \n(e.g. in swt browser widget)

	BuildingBlock "*" --> "1" HelpMessage : < provides help/information about




	class YamlRepresentation {
		<<create>>YamlRepresentation(BuildingBlock)
	}
	BuildingBlock -left- YamlRepresentation

	



'---------------------------------------------------------
'BuildingBlockBuilder
'---------------------------------------------------------
namespace BuildingBlockBuilder {
	class Director {

		+createSensorFromYaml(sensorFile: Yaml): Sensor
		+constructXYRepresentation()
		+constructNTimeRepresentation()
		+constructDS18B20TemperatureSensor()
		+constructBMPx80PressureSensor()
		+constructINA219CurrentAndVoltageSensor()
		+constructMMA8451Accelerometer()



	}

	class Builder {
		-linkToYaml: String
		+{abstract} fetchBuildingBlock(): BuildingBlock
		+snakeYaml.load(): hashMap
	}


	class "java.util.HashMap<K,V>" as HM{


	}

	Builder "1" --> "1" HM


	class SnakeYamlParser {
		+<<static>>parseYamlFile(Yaml fileToBeParsed): hashMap

	}

	note right of SnakeYamlParser
	  Already existing
	  parser for yaml files.
	end note


	SnakeYamlParser "1" --> "1" HM

	class SensorBuilder {
		+fetchBuildingBlock(): BuildingBlock
	}

	class PhysicalSensorBuilder {
		+fetchBuildingBlock(): BuildingBlock
		+addSensorProducerName(yaml Yaml): void

	}

	class VirtualSensorBuilder {
		+fetchBuildingBlock(): BuildingBlock
	}


	class TransformationBuilder {
		+fetchBuildingBlock(): BuildingBlock

	}
	class RepresentationBuilder {
		+fetchBuildingBlock(): BuildingBlock

	}
	class XYRepresentationBuilder {
		+fetchBuildingBlock(): BuildingBlock

	}
	class TableRepresentationBuilder {
		+fetchBuildingBlock(): BuildingBlock

	}






	SensorBuilder -up-|> Builder
	PhysicalSensorBuilder -up-|> SensorBuilder
	VirtualSensorBuilder -up-|> SensorBuilder
	
	TransformationBuilder -up-|> Builder
	RepresentationBuilder -up-|> Builder
	
	
	TableRepresentationBuilder -up-|> RepresentationBuilder
	XYRepresentationBuilder -up-|> RepresentationBuilder


	Director "1" --> "0..*" Builder : Staff

}
Model.BuildingBlockBuilder.SensorBuilder ..> Model.SensorLogic.Sensor
Model.BuildingBlockBuilder.TransformationBuilder ..> Model.TransformationLogic.Transformation
Model.BuildingBlockBuilder.RepresentationBuilder ..> Model.RepresentationLogic.Representation
Model.BuildingBlockBuilder.VirtualSensorBuilder ..> Model.SensorLogic.VirtualSensor
Model.BuildingBlockBuilder.PhysicalSensorBuilder ..> Model.SensorLogic.PhysicalSensor
Model.BuildingBlockBuilder.XYRepresentationBuilder ..> Model.RepresentationLogic.XYRepresentation
Model.BuildingBlockBuilder.TableRepresentationBuilder ..> Model.RepresentationLogic.TableRepresentation


	class BuildingBlockDirectory {

		- InitHashMap: HashMap<String: id, block: BuildingBlock>
		- ConfigHashMap: HashMap<int: id, block: BuildingBlock>
		--
		+ addInitBuildingBlock(id: String, block: BuildingBlock): boolean
		..
		+ addConfigBuildingBlock(id: int, block: BuildingBlock): boolean
		+ removeConfigBuildingBlock(id: String): boolean
		+ getInitBuildingBlock(id: String): BuildingBlock
		+ getConfigBuildingBlock(id: int): BuildingBlock
		+ addConfigConnection(bbId1: String, cId1: int, cId2: int, bbId2: String): boolean
		+ removeConfigConnection(bbId1: String, cId1: int, cId2: int, bbId2: String): boolean
		}

Model.BuildingBlockDirectory "1" --> "1" Model.BuildingBlockBuilder.Director
Model.MeasurementConfiguration "1" --> "1" Model.BuildingBlockBuilder.Director


PickUpPointViewFacades --> "*" UpdateInterface
PickUpPointViewFacades -left-> GraphicDataIolnterface
PickUpPointViewFacades --> ExceptionInterface
PickUpPointViewFacades --> MeasurementDataInterface

class PickUpPointViewFacades {
	 + getUpdateInterfaces(): UpdateInterface[]
	 + getGraphicDataIolnterface(): GraphicDataIolnterface
	 + getExceptionInterface(): ExceptionInterface
	 + getMeasurementDataInterface(): DataInterface
 }

 interface UpdateInterface {
 	+ updateConfig(): void
 }

interface GraphicDataIolnterface {
	  + getContentsOfRepresentationBlocks(): BufferedImage[]
 }
 
 interface ExceptionInterface {
	 + showGeneralException(title: String, description: String): void
	 + showBuildingBlockException(id: String, title: String, description: String): void
	 + showConnectionException(id: int, title: String, description: String): void
 }

Model.ExceptionInterface -- Model.MeasurementConfiguration 
Model.ExceptionInterface -- MeasurementRun

 interface MeasurementDataInterface {
 	+ pushShellForVisualisation(..): void
 }
Model.MeasurementDataInterface -- Model.RepresentationLogic.XYRepresentation








class Model.MRunReaction {
	+justWaiting():  void
	+indicateError(inChannelId: String, errorCode: double)
	+indicateTimeout(): void
	+indicateConnectionTerminated(): void
	+dispatchCompletePacketSet(completePacketSet: EnhancedValuePacket[])
}


MRunReaction "1" -- "1" Model.MeasurementRun
Model.MeasurementConfiguration "1" -- "1" Model.ChannelLogic.MRunInfo
Model.MeasurementConfiguration  -->  Model.BuildingBlockDirectory



}
@enduml
















old interfaces to 




interface IBuisnessLogic{
		+createModelFromYamlDom(modelDom: YamlDom): String
	}
	Model.Core.MeasurementConfiguration ..|> IBuisnessLogic
	
	interface IModelInformation{
		+getMeasurementConfig(): MeasurementConfiguration
		+addBuildingBlock(id: String)
		+removeBuildingBlock(id: String)
		+addConnection(firstChannelId: String, secondChannelId: String)
		+removeConnection(firstChannelId: String, secondChannelId: String)
	
	}
	Model.Core.MeasurementConfiguration ..|> IModelInformation
	
	interface IPrototypCollection {
		+getPrototyp(): BuildingBlock
		+clonePrototyp(id: String)
		+editPropertyOfPrototyp(key: String, value: Integer)
	}
	Model.Core.PrototypCollection ..|> IPrototypCollection
	
		
	
	
	interface IMeasurementRun{
		+pause()
		+start()
		+reset()
	}
	Model.Core.MeasurementRun ..|> IMeasurementRun



note bottom of IBuisnessLogic
	 createModelFromYamlDom() 
	 examines semantic validity 
	 and returns an appropriate result 
	 to the controller. 
	end note















Brainstorming:

NachIMeasurement









