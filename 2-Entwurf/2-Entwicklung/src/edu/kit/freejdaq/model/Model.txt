@startuml






namespace Model {







	class MeasurementRun {

		+start(): boolean
		+pause(): boolean
		+resume(): boolean
		+reset(): boolean
		+setUpdateRate(MeasurementConfiguration config): boolean
		-checkSensorInChannelStates(): boolean

	}

	enum MesurementRunState{
		INITIAL_STATE
		RUNNING
		PAUSED
	}
	MeasurementRun -> MesurementRunState



	class MeasurementConfiguration{
		+MeasurementConfiguration(pathToFile: String, updateRate: double)
		-pathToFile: String
		-updateRate: double
		-createConfigId( id: String): long
		-cloneInitBlock(id: String): BuildingBlock
		+getPathToFile(): String
		-checkForCycle(): boolean
 		+getMeasurementConfig(): MeasurementConfiguration
 		+addBuildingBlock(id: String)
		+removeBuildingBlock(id: String)
		+addConnection(firstChannelId: String, secondChannelId: String)
		+removeConnection(firstChannelId: String, secondChannelId: String)

 		+createModelFromYamlDom(modelDom: YamlDom): String

	}
	MeasurementConfiguration "1" -- "*" MeasurementRun


	abstract class BuildingBlock
	{

		-initId: String
		-configId: long
		-name: String
		-userInfo: String
		+setId()
		+addInChannel(id: String, name: String): void
		+addOutChannel(id: String, name: String): void
		+removeInChannel(id: String, name: String): void
		+removeOutChannel(id: String, name: String): void



	}


	MeasurementConfiguration "1" -- "*" BuildingBlock

	


	namespace TransformationLogic {
		abstract class Transformation {
			+<<create>> Transformation()
			+<<create>> Transformation(Yaml inputTransformationYaml)
			+setFunction(String inputFunction)
			+{abstract} applyFunction(packet: TimeSpampValuePair): void
			{abstract} processValue(packet: TimeSpampValuePair): boolean
		}
		class Function {
			<<create>>Function(String inputFunction) : Function
			+applyFunction(packet: TimeSpampValuePair): void
			
		}
		Function "1" - "*" Transformation
	}


	BuildingBlock <|-  Model.TransformationLogic.Transformation
	

	namespace RepresentationLogic {

		abstract class Representation{

			{abstract} processValue(packet: TimeSpampValuePair): boolean


			}

		class "TableRespresentation" as TR{
			processValue(packet: TimeSpampValuePair): boolean

		}


		class XYRepresentation {
			processValue(packet: TimeSpampValuePair): boolean
			traceName: String
			title: String
			xAxisName: String
			yXisName: String
			hasToolBar: boolean


		}

		note bottom of  Model.RepresentationLogic.XYRepresentation
	  		use eclipse nebula
	  		for display
		end note
		XYRepresentation --|> Representation
		TR   --|> Representation


	}
	BuildingBlock <|--  Model.RepresentationLogic.Representation

	namespace SensorLogic {

		abstract class Sensor{
			{abstract} processValue(packet: TimeSpampValuePair): boolean

			}

		 class PhysicalSensor{
		 	processValue(packet: TimeSpampValuePair): boolean
		 }
		 class VirtualSensor{
		 	processValue(packet: TimeSpampValuePair): boolean
		 }
		 VirtualSensor --|> Sensor
		 PhysicalSensor --|> Sensor
	}
	BuildingBlock <|-- Model.SensorLogic.Sensor


	namespace ChannelLogic {

	class Channel {
		-id: String
		-value: long
		+ establishConnection(targetChannelId: String)
		+ receiveValue()
		+ connect(): void
		+ unConnect(): void
		+ receiveValue(): void
		+ eraseValue(): void
		+ {abstract} forwardValue(): void

	}
	

	note top of Channel
	  first part of channelId is
	  the corresponding buildingBlockId
	end note

	abstract class ChannelState {
		+ {abstract} establishConnection(targetChannelId: String)
		+ {abstract} receiveValue()
	}
	Channel --> ChannelState
	note right of ChannelState
	  Schablonenmethode um Unterschiede zwischen
	  In und Out Channeln zu überbrücken
	end note
	class Connected{
		+ establishConnection(targetChannelId: String)
		+ receiveValue()
	}
	Connected --|> ChannelState
	class UnConnected{
		+ establishConnection(targetChannelId: String)
		+ receiveValue()
	}
	UnConnected --|> ChannelState
	class ValueReady{
		+ establishConnection(targetChannelId: String)
		+ receiveValue()
	}
	ValueReady --|> ChannelState
	class InChannel{
		-varName: String
		+forwardValue(): void
	}

	InChannel --|> Channel

	class OutChannel{
		-channelName: String
		+forwardValue(): void
	}

	class MRunInfo {
	+getAllInChannelIds(): String[]
	+getErrorCodes(inChannelId: String): double[]
	+getTimeoutOption(): long
	}



	OutChannel --|> Channel
	OutChannel "1" -- "1" InChannel
	note right of OutChannel
	  forwardValue wird bei
	  receive Value aufgerufen.
	  Hier ausimplementiert.
	end note

	note left of OutChannel
	  channelName steht für Funktionsnamen
	   bei Trafos und für
	   Channelname bei Sensoren
	end note


	


	}

	BuildingBlock "1" --> "*" Model.ChannelLogic.InChannel
	BuildingBlock "1" --> "*" Model.ChannelLogic.OutChannel

	class HelpMessage{
		- messageFileName : String
		+ HelpMessage(msgFile : String)
		+ displayMessage() : void
	}
	note bottom of HelpMessage : "messageFileName" leads to [html/markdown/?] \nfile containing message text, \nwhich can be displayed by the application \n(e.g. in swt browser widget)

	BuildingBlock "*" --> "1" HelpMessage : < provides help/information about




	class YamlRepresentation {
		<<create>>YamlRepresentation(block: BuildingBlock)
	}
	BuildingBlock -left- YamlRepresentation

	



'---------------------------------------------------------
'BuildingBlockBuilder
'---------------------------------------------------------
namespace BuildingBlockBuilder {
	class Director {

		+createSensorFromYaml(sensorFile: Yaml): Sensor
		+constructXYRepresentation()
		+constructNTimeRepresentation()
		+constructDS18B20TemperatureSensor()
		+constructBMPx80PressureSensor()
		+constructINA219CurrentAndVoltageSensor()
		+constructMMA8451Accelerometer()
		+constructTransformation()


	}

	class Builder {
		-linkToYaml: String
		+{abstract} fetchBuildingBlock(): BuildingBlock
		+snakeYaml.load(): hashMap
	}


	class "java.util.HashMap<K,V>" as HM{


	}

	Builder "1" --> "1" HM


	class SnakeYamlParser {
		+<<static>>parseYamlFile(Yaml fileToBeParsed): hashMap

	}

	note right of SnakeYamlParser
	  Already existing
	  parser for yaml files.
	end note


	SnakeYamlParser "1" --> "1" HM

	class SensorBuilder {
		+fetchBuildingBlock(): BuildingBlock
	}

	class PhysicalSensorBuilder {
		+fetchBuildingBlock(): BuildingBlock
		+addSensorProducerName(yaml Yaml): void

	}

	class VirtualSensorBuilder {
		+fetchBuildingBlock(): BuildingBlock
	}


	class TransformationBuilder {
		+fetchBuildingBlock(): BuildingBlock

	}
	class RepresentationBuilder {
		+fetchBuildingBlock(): BuildingBlock

	}
	class XYRepresentationBuilder {
		+fetchBuildingBlock(): BuildingBlock

	}
	class TableRepresentationBuilder {
		+fetchBuildingBlock(): BuildingBlock

	}






	SensorBuilder -up-|> Builder
	PhysicalSensorBuilder -up-|> SensorBuilder
	VirtualSensorBuilder -up-|> SensorBuilder
	
	TransformationBuilder -up-|> Builder
	RepresentationBuilder -up-|> Builder
	
	
	TableRepresentationBuilder -up-|> RepresentationBuilder
	XYRepresentationBuilder -up-|> RepresentationBuilder


	Director "1" --> "0..*" Builder : Staff

}


Model.BuildingBlockBuilder.TableRepresentationBuilder ..> Model.RepresentationLogic.TR
Model.BuildingBlockBuilder.SensorBuilder ..> Model.SensorLogic.Sensor
Model.BuildingBlockBuilder.TransformationBuilder ..> Model.TransformationLogic.Transformation
Model.BuildingBlockBuilder.RepresentationBuilder ..> Model.RepresentationLogic.Representation
Model.BuildingBlockBuilder.VirtualSensorBuilder ..> Model.SensorLogic.VirtualSensor
Model.BuildingBlockBuilder.PhysicalSensorBuilder ..> Model.SensorLogic.PhysicalSensor
Model.BuildingBlockBuilder.XYRepresentationBuilder ..> Model.RepresentationLogic.XYRepresentation



	class BuildingBlockDirectory {

		- InitHashMap: HashMap<id: String, block: BuildingBlock>
		- ConfigHashMap: HashMap<id: long, block: BuildingBlock>
		--
		+ addInitBuildingBlock(id: String, block: BuildingBlock): boolean
		..
		+ addConfigBuildingBlock(id: long, block: BuildingBlock): boolean
		+ removeConfigBuildingBlock(id: String): boolean
		+ getInitBuildingBlock(id: String): BuildingBlock
		+ getConfigBuildingBlock(id: long): BuildingBlock
		+ addConfigConnection(bbId1: String, cId1: long, cId2: long, bbId2: String): boolean
		+ removeConfigConnection(bbId1: String, cId1: long, cId2: long, bbId2: String): boolean
		}

Model.BuildingBlockDirectory "1" --> "1" Model.BuildingBlockBuilder.Director
Model.MeasurementConfiguration "1" --> "1" Model.BuildingBlockBuilder.Director




class PickUpPointViewFacades {
	 + getUpdateInterfaces(): UpdateInterface[]
	 + getGraphicDataIolnterface(): GraphicDataIolnterface
	 + getExceptionInterface(): ExceptionInterface
	 + getMeasurementDataInterface(): DataInterface
 }

 interface UpdateInterface {
 	+ updateConfig(): void
 }
Model.UpdateInterface -- Model.BuildingBlockBuilder.Director

 interface GraphicDataIolnterface {
	  + getContentsOfRepresentationBlocks(): BufferedImage[]
 }
 
 interface ExceptionInterface {
	 + showGeneralException(title: String, description: String): void
	 + showBuildingBlockException(id: String, title: String, description: String): void
	 + showConnectionException(id: long, title: String, description: String): void
 }

Model.ExceptionInterface -- Model.MeasurementConfiguration 
Model.ExceptionInterface -- Model.MeasurementRun

 interface MeasurementDataInterface {
 	+ pushShellForVisualisation(..): void
 }
Model.MeasurementDataInterface -- Model.RepresentationLogic.XYRepresentation

PickUpPointViewFacades --> "*" UpdateInterface
PickUpPointViewFacades --> GraphicDataIolnterface
PickUpPointViewFacades --> ExceptionInterface
PickUpPointViewFacades --> MeasurementDataInterface
GraphicDataIolnterface --> Model.RepresentationLogic.XYRepresentation





class Model.MRunReaction {
	+justWaiting():  void
	+indicateError(inChannelId: String, errorCode: double)
	+indicateTimeout(): void
	+indicateConnectionTerminated(): void
	+dispatchCompletePacketSet(completePacketSet: EnhancedValuePacket[])
}


MRunReaction  --  Model.MeasurementRun
Model.MeasurementRun  --  Model.ChannelLogic.MRunInfo
Model.MeasurementConfiguration  -->  Model.BuildingBlockDirectory



class hidd {

}
hide Model.hidd


Model.BuildingBlockDirectory -up[hidden]- Model.hidd
Model.BuildingBlockBuilder -up[hidden]- Model.BuildingBlockDirectory
Model.ChannelLogic -up[hidden]--------- Model.BuildingBlockBuilder



}
@enduml
















old interfaces to 




















Brainstorming:

NachIMeasurement









