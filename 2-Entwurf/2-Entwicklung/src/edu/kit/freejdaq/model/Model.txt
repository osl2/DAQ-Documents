@startuml








package kit.edu.freejdaq.Model {





	class MeasurementRun {

		+start(): boolean
		+pause(): boolean
		+resume(): boolean
		+reset(): boolean
		+setUpdateRate(MeasurementConfiguration config): boolean

	}

	enum MesurementRunState{
		INITIAL_STATE
		RUNNING
		PAUSED
	}
	MeasurementRun -> MesurementRunState



	class MeasurementConfiguration{
		-pathToFile: String
		-updateRate: float
		-listOfAllChannels: <Channel>
		-configurationAdjacencyList: configuration[]
		+getPathToFile(): String
		+addBlock(BuildingBlock block): boolean
 		+removeBlock(Integer blockId): boolean

	}
	MeasurementConfiguration "1" -- "*" MeasurementRun
	

	'----------------------------------------------------------------------------------------
	'PrototypCollection: List of all predefined and custom BuildingBlocks
	'----------------------------------------------------------------------------------------

	class PrototypCollection{
		 +returnCloneOfBlock(BuildingBlock: block)
	}


	abstract class BuildingBlock
	{

		-id: String
		-name: String
		-userInfo: String
		+setId()
		+addInChannel(id: String, name: String): void
		+addOutChannel(id: String, name: String): void
		+removeInChannel(id: String, name: String): void
		+removeOutChannel(id: String, name: String): void



	}


	MeasurementConfiguration "1" -- "*" BuildingBlock

	PrototypCollection "1" -- "*" BuildingBlock


	namespace TransformationLogic {
		abstract class Transformation {
			+<<create>> Transformation()
			+<<create>> Transformation(Yaml inputTransformationYaml)
			+setFunction(String inputFunction)
			+{abstract} applyFunction(): Integer
		}
		class Function {
			<<create>>Function(String inputFunction) : Function
			+applyFunction(Integer data)
		}
		AdditionTransformation -up-|> Transformation
		AverageTransformation -up-|> Transformation
		MultiplicationTransformation -up-|> Transformation
		DataFlowTransformation -up-|> Transformation
		LinearMapping -up-|> DataFlowTransformation
		DependendOutputTransformation -up-|> DataFlowTransformation
		Function "1" - "*" Transformation

		class DataFlowTransformation {

		}
		note left of TransformationLogic.DataFlowTransformation
		Changes the output according to configuration.
		Does not influence the values of the data stream
		end note
	}


	BuildingBlock <|- TransformationLogic.Transformation
	'----------------------------------------------------------------------------------------
	'Note: The manager aspect of this diagramm can be found, in more detail, at another place.
	'It stands here for a complete overview
	'----------------------------------------------------------------------------------------
	'package kit.edu.freejdaq.configurationBlockManager {
	'	abstract class ConfigurationBlockManager{
	'		listOfBlocks : ConfigurationBlock[]
	'		{abstract}+add(BuildingBlock block): boolean
	'		{abstract}+remove(BuildingBlock block): boolean
	'		{abstract}+showAllBocks(BuildingBlock block): boolean
	'	}
	'
	'	class RepresentationManager {
	'
	'
	'	}
	'
	'}

	namespace RepresentationLogic {

		abstract class Representation{

			{abstract} processValue()


			}

		class TableRespresentation {
			processValue()

		}


		class XYRepresentation {
			processValue()
			traceName: String
			title: String
			xAxisName: String
			yXisName: String
			hasToolBar: boolean


		}

		note right of RepresentationLogic.XYRepresentation
	  		use eclipse nebula
	  		for display
		end note


		class ChannelXvsTime {
			processValue()
		}

		class ChannelXvsChannelY{
			processValue()

		}

			class NChannelvsTime{
			processValue()
		}
		XYRepresentation -up-|> Representation
		ChannelXvsChannelY -up-|> XYRepresentation
		ChannelXvsTime -up-|> XYRepresentation
		NChannelvsTime -up-|> XYRepresentation
		TableRespresentation   -down-|> Representation


	}
	BuildingBlock <|-- RepresentationLogic.Representation

	namespace SensorLogic {

		abstract class Sensor{
			´{abstract} processValue()

			}
		 class AnalogDigitalConverter {
			processValue()
		}

		class ADS1115 {
			processValue()
		}

		AnalogDigitalConverter -up-|> Sensor
		ADS1115 -up-|> AnalogDigitalConverter


		class CurrentPower {
			processValue()
		}

		class INA219 {
			processValue()
		}

		CurrentPower -up-|> Sensor
		INA219 -up-|> CurrentPower

		class SpectralSensor {
			processValue()
		}

		class AS7262 {
			processValue()
		}

		SpectralSensor -up-|> Sensor
		AS7262 -up-|> SpectralSensor

	}
	BuildingBlock <|-- SensorLogic.Sensor


	namespace ChannelLogic {

	class Channel {
		-id: String
		-value: int
		+ establishConnection(String targetChannelId)
		+ receiveValue()
		+ connect(): void
		+ unConnect(): void
		+ receiveValue(): void
		+ eraseValue(): void
		+ {abstract} forwardValue(): void

	}
	Channel ..|> IValueHandler

	note top of Channel
	  first part of channelId is
	  the corresponding buildingBlockId
	end note

	abstract class ChannelState {
		+ {abstract} establishConnection(String targetChannelId)
		+ {abstract} receiveValue()
	}
	Channel --> ChannelState
	note right of ChannelState
	  Schablonenmethode um Unterschiede zwischen
	  In und Out Channeln zu überbrücken
	end note
	class Connected{
		+ establishConnection(String targetChannelId)
		+ receiveValue()
	}
	Connected --|> ChannelState
	class UnConnected{
		+ establishConnection(String targetChannelId)
		+ receiveValue()
	}
	UnConnected --|> ChannelState
	class ValueReady{
		+ establishConnection(String targetChannelId)
		+ receiveValue()
	}
	ValueReady --|> ChannelState
	class InChannel{
		-varName: String
		+forwardValue(): void
	}
	
	InChannel --|> Channel
	
	class OutChannel{
		-channelName: String
		+forwardValue(): void
	}
	
	OutChannel --|> Channel
	
	note top of OutChannel
	  forwardValue wird bei 
	  receive Value aufgerufen. 
	  Hier ausimplementiert.
	end note
	
	note left of OutChannel
	  channelName steht für Funktionsnamen
	   bei Trafos und für 
	   Channelname bei Sensoren
	end note



	
	interface IValueHandler {

		processValue()
	}
	
	note right of IValueHandler
	  interface to provide
	  Data to a channel
	end note


	}
	
	BuildingBlock "1" --> "*" ChannelLogic.InChannel
	BuildingBlock "1" --> "*" ChannelLogic.OutChannel
	
	class HelpMessage{
		- messageFileName : String
		+ HelpMessage(msgFile : String)
		+ displayMessage() : void
	}
	note right of HelpMessage : "messageFileName" leads to [html/markdown/?] \nfile containing message text, \nwhich can be displayed by the application \n(e.g. in swt browser widget)

	BuildingBlock "*" --> "1" HelpMessage : < provides help/information about




	class YamlRepresentation {
		<<create>>YamlRepresentation(BuildingBlock)
	}
	BuildingBlock -left- YamlRepresentation

	}
	
		

'---------------------------------------------------------
'BuildingBlockBuilder
'---------------------------------------------------------
namespace BuildingBlockBuilder {
	class Director {

		+createSensorFromYaml(sensorFile: Yaml): Sensor
		+constructXYRepresentation()
		+constructNTimeRepresentation()
		+constructDS18B20TemperatureSensor()
		+constructBMPx80PressureSensor()
		+constructINA219CurrentAndVoltageSensor()
		+constructMMA8451Accelerometer()



	}

	class Builder {
		-linkToYaml: String
		+{abstract} fetchBuildingBlock(): BuildingBlock
		+snakeYaml.load(): hashMap





	}


	class "java.util.HashMap<K,V>" as HM{


	}

	Builder "1" --> "1" HM


	class SnakeYamlParser {
		+<<static>>parseYamlFile(Yaml fileToBeParsed): hashMap

	}

	note right of SnakeYamlParser
	  Already existing
	  parser for yaml files.
	end note


	SnakeYamlParser "1" --> "1" HM

	class SensorBuilder {
		+fetchBuildingBlock(): BuildingBlock

	}
	class TransformationBuilder {
		+fetchBuildingBlock(): BuildingBlock

	}
	class RepresentationBuilder {
		+fetchBuildingBlock(): BuildingBlock

	}

	SensorBuilder -up-|> Builder
	TransformationBuilder -up-|> Builder
	RepresentationBuilder -up-|> Builder




	Director "1" --> "0..*" Builder : Staff

}
BuildingBlockBuilder.SensorBuilder ..> SensorLogic.Sensor
BuildingBlockBuilder.TransformationBuilder ..> TransformationLogic.Transformation
BuildingBlockBuilder.RepresentationBuilder ..> RepresentationLogic.Representation


interface IMeasurementStreamListener {
		-receiveData(measuredValue: int): void
		-connectionTerminated(): void
	}


	note bottom of IBusinessLogic
	 createModelFromYamlDom() 
	 examines semantic validity 
	 and returns an appropriate result 
	 to the controller. 
	end note

	interface IBusinessLogic{
	+createModelFromYamlDom(modelDom: YamlDom): String
	+addBuildingBlock(id: String)
	+removeBuildingBlock(id: String)
	+addConnection(firstChannelId: String, secondChannelId: String)
	+removeConnection(firstChannelId: String, secondChannelId: String)
	+clonePrototyp(id: String)
	+editPropertyOfPrototyp(key: String, value: Integer)
	}

	interface IModelInformation{
	+getMeasurementConfig(): MeasurementConfiguration
	+getPrototyp(): BuildingBlock
	}
	interface IMeasurementRun{
	+pause()
	+start()
	+reset()
	
	}

		IMeasurementStreamListener <|.. Channel
		IBusinessLogic <|.. MeasurementConfiguration
		IModelInformation <|.. MeasurementConfiguration
		IMeasurementRun <|.. MeasurementRun
		IBusinessLogic <|.. BuildingBlockBuilder.Director








@enduml


old stuff
class ChannelManager {
		-numberOfElements: Integer
		+getChannel(Integer id): Channel
		+setChannel(Integer id): boolean
		+addChannel(Channel channel): boolean
		+removeChannel(Integer id): boolean
	}
	ChannelManager "1" -- "1" BuildingBlock
	ChannelManager "1" o-- "1..*" Channel


