@startuml
'------------------------------------------------------------------------
'Backend
'------------------------------------------------------------------------
namespace Backend {

	PickPointForAgentsBasedOnSsh -up-> IAccessToSensorInfo
	PickPointForAgentsBasedOnSsh -up-> IAccessToMeasurementRun
	PickPointForAgentsBasedOnSsh .up.> InitDataForSsh

	MeasurementRunAgentForSsh --> "*" IMStreamListener

	SensorInfoAgentForSsh .right.|> IAccessToSensorInfo
	MeasurementRunAgentForSsh .right.|> IAccessToMeasurementRun

	SshToPi -up-|> CommunicationWithPi
	WebSocketToPi  -right-|> CommunicationWithPi
	UsbToPi -right-|> CommunicationWithPi

	SshToPi -up-> NetworkConfiguration
	WebSocketToPi -down-> NetworkConfiguration

	CommunicationWithPi --> ICommandResponseListener
	MeasurementRunAgentForSsh ..|> ICommandResponseListener

	MeasurementRunAgentForSsh -left-> CommunicationWithPi
	SensorInfoAgentForSsh -down-> CommunicationWithPi

	MeasurementRunAgentForSsh --> MeasurementState


	IMStreamListener  ..|> Cache.MStreamListener


	class NetworkConfiguration {
	   -port: int
	   -ipAddressOfPi: String
	}

	abstract class CommunicationWithPi {
		-busy: boolean
		-pathToRemoteDir: String
		-pathToLocalDir: String
		+CommunicationWithPi(pathToRemoteDir: String, pathToLocalDir: String)
	    +{abstract}executeCompleteCommandWithTimeout(command: String, timeOut: int): String[]
	    +{abstract}copyFileFromPi(nameOfFile: String): boolean
	    +{abstract}copyFileToPi(nameOfFile: String): boolean
	    +{abstract}executeCommandContinuously(command: String, listeningAgent: ICommandResponseListener): void
	    +{abstract}disconnect(): void
	}
	

	interface ICommandResponseListener {
		receivePartOfResponse(response: String; finished: boolean)
	}

	

	

	class SshToPi {
		-username: String
		-password: String
		+SshAndScpTo(username: String, password: String)
		+executeCompleteCommandWithTimeout(command: String, timeOut: int): String[]
	    +copyFileFromPi(nameOfFile: String): boolean
	    +copyFileToPi(nameOfFile: String): boolean
	    +executeCommandContinuously(command: String, listeningAgent: ICommandResponseListener): void
	    +disconnect(): void
	}

	
	interface IMStreamListener {
		+ receiveMDataSet(channelId: String, timeStamp: long, value: double): void
		+ connectionTerminated(): void
	}



	interface IAccessToSensorInfo {
		+getIdsOfAvailableSensors(): String[]
		+getYamlFile(sensorId: String): boolean
		+setYamlFile(sensorId: String): boolean
	}



	interface IAccessToMeasurementRun{
		+start(sensorIDs: string[], dataListeners: IMStreamListener[]): boolean
		+pause(): boolean
		+continue(): boolean
		+stop(): boolean
	}

	enum MeasurementState {
	  INITAL_STATE
	  RUNNING
	  PAUSED
	}


		class MeasurementRunAgentForSsh {
			+MeasurementRunAgentForSsh(foundation: CommunicationWithPi)
			+start(sensorIDs: string[], dataListeners: IMStreamListener[}): boolean
			+pause(): boolean
			+continue(): boolean
			+stop(): boolean
			+receivePartOfResponse(response: String; finished: boolean)
		}

		class SensorInfoAgentForSsh {
			+SensorInfoAgentForSsh(foundation: CommunicationWithPi)
			+getIdsOfAvailableSensors(): String[]
			+getYamlFile(sensorId: String): boolean
			+setYamlFile(sensorId: String): boolean
		}



	class PickPointForAgentsBasedOnSsh {
		+{static}getPickPointForAgentsBasedOnSsh(initData: InitDataForSsh): PickPointForAgentsBasedOnSsh
		+getIAccessToMeasurementRun(): IAccessToSensorInfo
		+getIAccessToSensorInfo(): IAccessToSensorInfo
	}
	
	
	class InitDataForSsh {
	 	+ ipAddressOfPi: String, 
	 	+ port: int, 
	 	+ username: String, 
	 	+ password: String, 
	 	+ pathToRemoteDir: String, 
	 	+ pathToLocalDir: String
	}

	note bottom of MeasurementRunAgentForSsh
		To separate technical aspect of communication 
		from application specific aspect, this Agent
		receives technical events and forwards them to
		its registered application specific clients. 
	end note

}
@enduml
