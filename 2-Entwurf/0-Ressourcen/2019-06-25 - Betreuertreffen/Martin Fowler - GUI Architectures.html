<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0148)file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta content="uft-8" name="charset">

<title>GUI Architectures</title>

<meta content="summary" name="twitter:card">

<meta content="16665197" name="twitter:site:id">

<meta content="GUI Architectures" property="og:title">

<meta content="https://martinfowler.com/eaaDev/uiArchs.html" property="og:url">

<meta content="Describing the way architectures for UIs have evolved over the years, in particular the many and often misunderstood definitions for Model-View-Controller." property="og:description">

<meta content="https://martinfowler.com/logo-sq.png" property="og:image">

<meta content="martinfowler.com" property="og:site_name">

<meta content="article" property="og:type">

<meta content="2006-07-18" property="og:article:modified_time">

<meta content="width=device-width, initial-scale=1" name="viewport">

<link href="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/eaa-dev.css" rel="stylesheet" type="text/css">
</head>

<body><div id="banner" style="background-image: url(&quot;/banner.png&quot;); background-repeat: no-repeat">

<div class="name-logo"><a href="https://martinfowler.com/"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/mf-name-white.png"></a></div>
  <div class="search">
    <!-- SiteSearch Google -->
    <form method="GET" action="https://www.google.com/search">
      <input type="hidden" name="ie" value="UTF-8">
      <input type="hidden" name="oe" value="UTF-8">
      <input class="field" type="text" name="q" size="15" maxlength="255" value="">
      <button class="button" type="submit" name="btnG" value=" " title="Search">
      <input type="hidden" name="domains" value="martinfowler.com">
      <input type="hidden" name="sitesearch" value=""> 
      <input type="hidden" name="sitesearch" value="martinfowler.com">
    
  </button></form></div>

<div class="menu-button navmenu-button"><a class="icon icon-bars" href="https://martinfowler.com/eaaDev/uiArchs.html#navmenu-bottom"></a></div>

<div class="top-menu">
<ul>
<li><a class="" href="https://refactoring.com/">Refactoring</a></li>

<li><a class="" href="https://martinfowler.com/agile.html">Agile</a></li>

<li><a class="" href="https://martinfowler.com/design.html">Design</a></li>

<li><a class="" href="https://martinfowler.com/aboutMe.html">About</a></li>

<li><a class="tw" href="https://www.thoughtworks.com/">ThoughtWorks</a></li>

<li><a class="icon icon-rss" href="https://martinfowler.com/feed.atom" title="feed"></a></li>

<li><a class="icon icon-twitter" href="https://www.twitter.com/martinfowler" title="twitter stream"></a></li>
</ul>
</div>
</div>
<div class="div" id="top-navmenu">
<header class="navmenu">
<div class="nav-head">  <div class="search">
    <!-- SiteSearch Google -->
    <form method="GET" action="https://www.google.com/search">
      <input type="hidden" name="ie" value="UTF-8">
      <input type="hidden" name="oe" value="UTF-8">
      <input class="field" type="text" name="q" size="15" maxlength="255" value="">
      <button class="button" type="submit" name="btnG" value=" " title="Search">
      <input type="hidden" name="domains" value="martinfowler.com">
      <input type="hidden" name="sitesearch" value=""> 
      <input type="hidden" name="sitesearch" value="martinfowler.com">
    
  </button></form></div>

<div class="closediv">
<span class="close" title="close"></span>
</div>
</div>

<div class="nav-body">
<div class="topics">
<h2>Topics</h2>

<p><a href="https://martinfowler.com/design.html">Design</a></p>

<p><a href="https://refactoring.com/">Refactoring</a></p>

<p><a href="https://martinfowler.com/agile.html">Agile</a></p>

<p><a href="https://martinfowler.com/delivery.html">Continuous Delivery</a></p>

<p><a href="https://martinfowler.com/microservices">Microservices</a></p>

<p><a href="https://martinfowler.com/nosql.html">NoSQL</a></p>

<p><a href="https://martinfowler.com/dsl.html">DSL</a></p>
</div>

<div class="about">
<h2>about me</h2>

<p><a href="https://martinfowler.com/aboutMe.html">About</a></p>

<p><a href="https://martinfowler.com/books">Books</a></p>

<p><a href="https://martinfowler.com/faq.html">FAQ</a></p>
</div>

<div class="content">
<h2>content</h2>

<p><a href="https://martinfowler.com/videos.html">Videos</a></p>

<p><a href="https://martinfowler.com/tags">Content Index</a></p>

<p><a href="https://martinfowler.com/articles/eurogames">Board Games</a></p>

<p><a href="https://martinfowler.com/photos">Photography</a></p>
</div>

<div class="tw">
<h2>ThoughtWorks</h2>

<p><a href="https://thoughtworks.com/blogs">Blogs</a></p>

<p><a href="https://thoughtworks.com/careers">Careers</a></p>

<p><a href="https://thoughtworks.com/products">Products</a></p>
</div>

<div class="feeds">
<h2>follow</h2>

<p><a href="https://www.twitter.com/martinfowler">Twitter</a></p>

<p><a href="https://martinfowler.com/feed.atom">RSS</a></p>
</div>
</div>
</header>
</div>

<div class="contents dropdown-container">
<button class="dropdown-button">
<h2>Contents</h2>
</button>

<div class="hidden" id="dropdownLinks"><a href="https://martinfowler.com/eaaDev/uiArchs.html#FormsAndControls">Forms and Controls</a><a href="https://martinfowler.com/eaaDev/uiArchs.html#ModelViewController">Model View Controller</a><a href="https://martinfowler.com/eaaDev/uiArchs.html#VisualworksApplicationModel">VisualWorks Application Model</a><a href="https://martinfowler.com/eaaDev/uiArchs.html#Model-view-presentermvp">Model-View-Presenter (MVP)</a><a href="https://martinfowler.com/eaaDev/uiArchs.html#HumbleView">Humble View</a></div>
</div>

<div id="content">
<h1>GUI Architectures</h1>

<p class="abstract"><i>There have been many different ways to organize the code
  for a rich client system. Here I discuss a selection of those that I
  feel have been the most influential and introduce how they relate to
  the patterns.</i></p>

<div class="frontMatter">
<div class="frontLeft">
<p class="date">18 July 2006</p>

<div class="author"><img alt="Photo of Martin Fowler" src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/mf.jpg" width="80">
<p class="name"><a href="https://martinfowler.com/" rel="author">Martin Fowler</a></p>
</div>

<div class="clear"></div>

<div class="translations"><b>Translations: </b><a href="http://anguerde.com/uiarchs/">Greek</a></div>
</div>

<div class="frontRight">
<div class="contents">
<h2>Contents</h2>

<ul>
<li><a href="https://martinfowler.com/eaaDev/uiArchs.html#FormsAndControls">Forms and Controls</a></li>

<li><a href="https://martinfowler.com/eaaDev/uiArchs.html#ModelViewController">Model View Controller</a></li>

<li><a href="https://martinfowler.com/eaaDev/uiArchs.html#VisualworksApplicationModel">VisualWorks Application Model</a></li>

<li><a href="https://martinfowler.com/eaaDev/uiArchs.html#Model-view-presentermvp">Model-View-Presenter (MVP)</a></li>

<li><a href="https://martinfowler.com/eaaDev/uiArchs.html#HumbleView">Humble View</a></li>
</ul>
</div>
</div>
</div>

<div class="eaadev-notice"><p>This is part of the <a href="https://martinfowler.com/eaaDev">Further Enterprise Application Architecture development</a> writing that I was doing in the mid 2000’s. Sadly too many other things have claimed my attention since, so I haven’t had time to work on them further, nor do I see much time in the foreseeable future. As such this material is very much in draft form and I won’t be doing any corrections or updates until I’m able to find time to work on it again.</p>

</div>

<div class="paperBody">
<p>Graphical user interfaces have become a familiar part of our
    software landscape, both as users and as developers. Looking at it
    from a design perspective they represent a particular set of
    problems in system design - problems that have led to a number of
    different but similar solutions.</p>

<p>My interest is identifying common and useful patterns for
    application developers to use in rich-client development. I've
    seen various designs in project reviews and also various designs
    that have been written in a more permanent way. Inside these
    designs are the useful patterns, but describing them is often not
    easy. Take Model-View-Controller as an example. It's often
    referred to as a pattern, but I don't find it
    terribly useful to think of it as a pattern because it contains
    quite a few different ideas. Different people reading about MVC in
    different places take different ideas from it and describe these
    as 'MVC'. If this doesn't cause enough confusion you then get the
    effect of misunderstandings of MVC that develop through a system
    of Chinese whispers.</p>

<p>In this essay I want to explore a number of interesting
    architectures and describe my interpretation of their most
    interesting features. My hope is that this will provide a context
    for understanding the patterns that I describe. </p>

<p>To some extent you can see this essay as a kind of intellectual
history that traces ideas in UI design through multiple architectures
over the years. However I must issue a caution about this.
Understanding architectures isn't easy, especially when many of them
change and die. Tracing the spread of ideas is even harder, because
people read different things from the same architecture. In particular
I have not done an exhaustive examination of the architectures I
describe. What I have done is referred to common descriptions of the
designs. If those descriptions miss things out, I'm utterly ignorant
of that. So don't take my descriptions as authoritative.
Furthermore there are things I've left
out or simplified if I didn't think they were particularly relevant.
Remember my primary interest is the underlying patterns, not in the
history of these designs. </p>

<p>(There is something of an exception here, in
    that I did have access to a running Smalltalk-80 to examine
    MVC. Again I wouldn't describe my examination of it as exhaustive,
    but it did reveal things that common descriptions of it failed to
    - which even further makes me cautious about descriptions of other
      architectures that I have here. If you are familiar with one of
      these architectures and you see I have something important that
      is incorrect and missing I'd like to know about it. I also think
      that a more exhaustive survey of this territory would be a good
      object of academic study.)</p>

<div id="FormsAndControls"><hr class="topSection">
<h2>Forms and Controls</h2>

<p>I shall begin this exploration with an architecture that is
      both simple and familiar. It doesn't have a common name, so for
      the purposes of this essay I shall call it "Forms and
      Controls". It's a familiar architecture because it was the one
      encouraged by client-server development environments in the 90's -
      tools like Visual Basic, Delphi, and Powerbuilder. It continues
      to be commonly used, although also often vilified by design
      geeks like me.</p>

<p>To explore it, and indeed the other architectures, I'll use a
      common example. In New England, where I live, there is a
      government program that monitors the amount of ice-cream
      particulate in the atmosphere. If the concentration is too low,
      this indicates that we aren't eating enough ice-cream - which
      poses a serious risk to our economy and public order. (I like to
      use examples that are no less realistic as you usually find
      in books like this.)</p>

<p>To monitor our ice-cream health, the government has set up
      monitoring stations all over the New England states. Using
      complex atmospheric modeling the department sets a target for
      each monitoring station. Every so often staffers go out on an
      assessment where they go to various stations and note the actual
      ice-cream particulate concentrations. This UI allows them to
      select a station, and enter the date and actual value. The
      system then calculates and displays the variance from the
      target. The system highlights the variance in red when it is 10%
      or more below the target, or in green when 5% or more above the
      target.</p>

<div class="figure " id="uiArchs_assessmentUI.gif"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/assessmentUI.gif">
<p class="photoCaption">Figure 1: The UI I'll use as an
      example. </p>
</div>

<div class="clear"></div>

<p>As we look at this screen we can see there is an important
      division as we put it together. The form is specific to our
      application, but it uses controls that are generic. Most GUI
      environments come with a hefty bunch of common controls that we
      can just use in our application. We can build new controls
      ourselves, and often it's a good idea to do so, but there is
      still a distinction between generic reusable controls
      and specific forms. Even specially written controls can be reused across multiple forms.</p>

<p>The form contains two main responsibilities:</p>

<ul>
<li>Screen layout: defining the arrangement of the controls on the screen,
        together with their hierarchic structure with one other.</li>

<li>Form logic: behavior that cannot be easily programmed into the
        controls themselves.</li>
</ul>

<p>Most GUI development environments allow the developer to
      define screen layout with a graphical editor that allows you to
      drag and drop the controls onto a space in the form. This
      pretty much handles the form layout. This way it's easy to setup
      a pleasing layout of controls on the form (although it isn't
      always the best way to do it - we'll come to that later.)</p>

<p>The controls display data - in this case about the reading. This
      data will pretty much always come from somewhere else, in this
      case let's assume a SQL database as that's the environment that
      most of these client-server tools assume. In most situations
      there are three copies of the data involved: </p>

<ul>
<li>One copy of data lies in the database itself. This copy is
        the lasting record of the data, so I call it the <b>record
        state</b>. The record state is usually shared and visible
        to multiple people via various mechanisms.</li>

<li>A further copy lies inside in-memory <a href="https://martinfowler.com/eaaCatalog/recordSet.html">Record Sets</a> within the application. Most
        client-server environments provided tools which made this easy
        to do. This data was only relevant for one particular session
        between the application and the database, so I call it <b>session
        state</b>. Essentially this provides a temporary local
        version of the data that the user works on until they save, or
        commit it, back to the database - at which point it merges
        with the record state. I won't worry about the issues around
        coordinating record state and session state here: I did go
        into various techniques in <a href="https://martinfowler.com/books.html#eaa">[P of EAA]</a>.</li>

<li>The final copy lies inside the GUI components
        themselves. This, strictly, is the data they see on the
        screen, hence I call it the <b>screen state</b>. It is
        important to the UI how screen state and session state are
        kept synchronized.</li>
</ul>

<p>Keeping screen state and session state synchronized is an
      important task. A tool that helped make this easier was  <a href="https://martinfowler.com/eaaDev/DataBinding.html">Data Binding</a>. The
      idea was that any change to either the control data, or the
      underlying record set was immediately propagated to the
      other. So if I alter the actual reading on the screen, the text
      field control effectively updates the correct column in the
      underlying record set.</p>

<p>In general data binding gets tricky because if you have to
      avoid cycles where a change to the control, changes the record
      set, which updates the control, which updates the record
      set.... The flow of usage helps avoid these - we load from the
      session state to the screen when the screen is opened, after
      that any changes to the screen state propagate back to the
      session state. It's unusual for the session state to be updated
      directly once the screen is up. As a result data binding might
      not be entirely bi-directional - just confined to initial upload
      and then propagating changes from the controls to the session state.</p>

<p><a href="https://martinfowler.com/eaaDev/DataBinding.html">Data Binding</a> handles much of the functionality of a
      client-sever application pretty nicely. If I change the actual value
      the column is updated, even changing the selected station alters the
      currently selected row in the record set, which causes the other
      controls to refresh.</p>

<p>Much of this behavior is built in by the framework builders,
      who look at common needs and make it easy to satisfy them. In
      particular this is done by setting values, usually called
      properties, on the controls. The control binds to a particular
      column in a record set by having its column name set through a
      simple property editor.</p>

<p>Using data binding, with the right kind of parameterization,
      can take you a long way. However it can't take you all the way -
      there's almost always some logic that won't fit with the
      parameterization options. In this case calculating the variance
      is an example of something that doesn't fit in this built in
      behavior - since it's application
      specific it usually lies in the form.</p>

<p>In order for this to work the form needs to be alerted
      whenever the value of the actual field changes, which
      requires the generic text field to call some specific behavior on
      the form. This is a bit more involved than taking a class
      library and using it through calling it as Inversion of Control
      is involved.</p>

<p>There are various ways of getting this kind of thing to work
      - the common one for client-server toolkits was the notion of
        events. Each control had a list of events it could raise. Any
        external object could tell a control that it was interested in
        an event - in which case the control would call that external
        object when the event was raised. Essentially this is just a
        rephrasing of the <a href="http://www.amazon.com/exec/obidos/tg/detail/-/0201633612">Observer</a> pattern where
        the form is observing the control. The framework usually
        provided some mechanism where the developer of the form could
        write code in a subroutine that would be invoked when the
        event occurred. Exactly how the link was made between event
        and routine varied between platform and is unimportant for
        this discussion - the point is that some mechanism existed to
        make it happen.</p>

<p>Once the routine in the form has control, it can then do
      whatever is needed. It can carry out the specific behavior and
      then modify the controls as necessary, relying on data binding
      to propagate any of these changes back to the session state.</p>

<p>This is also necessary because data binding isn't always
present. There is a large market for windows controls, not all of them
do data binding. If data binding isn't present then it's up to the
form to carry out the synchronization. This could work by
pulling data out of the record set into the widgets initially, and
copying the changed data back to the record set when the save button
was pressed.</p>

<p>Let's examine our editing of the actual value, assuming that
      data binding is present. The form
      object holds direct references to the generic controls. There'll
      be one for each control on the screen, but I'm just interested
      in the actual, variance, and target fields here.</p>

<div class="figure " id="uiArchs_formsAndControls-cd.gif"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/formsAndControls-cd.gif">
<p class="photoCaption">Figure 2: Class diagram for
      forms and controls</p>
</div>

<div class="clear"></div>

<p>The text field declares an event for text changed, when
      the form assembles the screen during initialization it
      subscribes itself to that event, binding it a method on itself -
      here <code>actual_textChanged</code>. </p>

<div class="figure " id="uiArchs_formsAndControls-seq.gif"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/formsAndControls-seq.gif">
<p class="photoCaption">Figure 3: Sequence diagram
      for changing a genre with forms and controls.</p>
</div>

<div class="clear"></div>

<p>When the user changes the actual value, the
      text field control raises its event and through the magic of
      framework binding the <code>actual_textChanged</code> is
      run. This method gets the text from the
      actual and target text fields, does the subtraction, and puts
      the value into the variance field. It also figures out what
      color the value should be displayed with and adjusts the text
      color appropriately.</p>

<p>We can summarize the architecture with a few soundbites:</p>

<ul>
<li>Developers write application specific forms that use
        generic controls.</li>

<li>The form describes the layout of controls on it.</li>

<li>The form observes the controls and has handler methods to
        react to interesting events raised by the controls.</li>

<li>Simple data edits are handled through data binding.</li>

<li>Complex changes are done in the form's event handling methods.</li>
</ul>
</div>

<div id="ModelViewController"><hr class="topSection">
<h2>Model View Controller</h2>

<p>Probably the widest quoted pattern in UI development is Model
      View Controller (MVC) - it's also the most misquoted. I've lost
      count of the times I've seen something described as MVC which
      turned out to be nothing like it. Frankly a lot of the reason
      for this is that parts of classic MVC don't really make sense
      for rich clients these days. But for the moment we'll take a
      look at its origins.</p>

<p>As we look at MVC it's important to remember that this was
      one of the first attempts to do serious UI work on any kind of
      scale. Graphical User Interfaces were not exactly common in the
      70's. The Forms and Controls model I've just described came
      after MVC - I've described it first because it's simpler, not
      always in a good way. Again I'll discuss Smalltalk 80's MVC
      using the assessment example - but be aware that I am taking a
      few liberties with the actual details of Smalltalk 80 to do this
      - for start it was a monochrome system.</p>

<p>At the heart of MVC, and the idea that was the most
      influential to later frameworks, is what I call <a href="https://martinfowler.com/eaaDev/SeparatedPresentation.html">Separated Presentation</a>. The idea behind <a href="https://martinfowler.com/eaaDev/SeparatedPresentation.html">Separated Presentation</a> is to make a clear division
      between domain objects that model our perception of the real
      world, and presentation objects that are the GUI elements we see
      on the screen. Domain objects should be completely self
      contained and work without reference to the presentation, they
      should also be able to support multiple presentations, possibly
      simultaneously. This approach was also an important part of the
      Unix culture, and continues today allowing many applications to
      be manipulated through both a graphical and command-line interface.</p>

<p>In MVC, the domain element is referred to as the model. Model
objects are completely ignorant of the UI. To begin discussing our
assessment UI example we'll take the model as a reading, with fields
for all the interesting data upon it. (As we'll see in a moment the
presence of the list box makes this question of what is the model
rather more complex, but we'll ignore that list box for a little bit.)</p>

<p>In MVC I'm assuming a <a href="https://martinfowler.com/eaaCatalog/domainModel.html">Domain Model</a> of regular objects, rather than
      the <a href="https://martinfowler.com/eaaCatalog/recordSet.html">Record Set</a> notion that I had in Forms
      and Controls. This reflects the general assumption behind the
      design. Forms and Controls assumed that most people wanted to
      easily manipulate data from a relational database, MVC assumes
      we are manipulating regular Smalltalk objects.</p>

<p>The presentation part of MVC is made of the two remaining
      elements: view and controller. The controller's job is to take
      the user's input and figure out what to do with it.</p>

<p>At this point I should stress that there's not just one view
and controller, you have a view-controller pair for each element of
the screen, each of the controls and the screen as a whole. So the
first part of reacting to the user's input is the various controllers
collaborating to see who got edited. In this case that's the
actuals text field so that text field controller would now handle what happens next.</p>

<div class="figure " id="uiArchs_mvc-deps.gif"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/mvc-deps.gif">
<p class="photoCaption">Figure 4: Essential dependencies between model,
      view, and controller. (I call this essential because in fact the
      view and controller do link to each other directly, but
      developers mostly don't use this fact.)</p>
</div>

<div class="clear"></div>

<p>Like later environments, Smalltalk figured out that you
wanted generic UI components that could be reused. In this case the
component would be the view-controller pair. Both were generic
classes, so needed to be plugged into the application specific
behavior. There would be an assessment  view that would represent the
whole screen and define the layout of the lower level controls, in
that sense similar to a form in Forms and Controllers. Unlike the
form, however, MVC has no event handlers on the assessment controller
for the lower level components.</p>

<div class="figure " id="uiArchs_mvc-cd.gif"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/mvc-cd.gif">
<p class="photoCaption">Figure 5: Classes for an
      MVC version of an ice-cream monitor display</p>
</div>

<div class="clear"></div>

<p>The configuration of the text field comes from giving it
      a link to its model, the reading, and telling it what what method
      to invoke when the text changes. This is set to '#actual:' when the
      screen is initialized (a leading '#' indicates a symbol, or
      interned string, in Smalltalk). The text field controller then makes a
      reflective invocation of that method on the reading to make the
      change. Essentially this is the same mechanism as occurs for
      <a href="https://martinfowler.com/eaaDev/DataBinding.html">Data Binding</a>, the control is linked to the
      underlying object (row) and told which method (column) it
      manipulates.</p>

<div class="figure " id="uiArchs_mvc-seq.gif"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/mvc-seq.gif">
<p class="photoCaption">Figure 6: Changing the actual value for MVC.</p>
</div>

<div class="clear"></div>

<p>So there is no overall object
observing low level widgets, instead the low level widgets observe the
model, which itself handles many of the decision that would be made by
the form. In this case, when it comes to figuring out the variance,
the reading object itself is the natural place to do that.</p>

<p>Observers do occur in MVC, indeed it's one of the ideas
credited to MVC. In this case all the views and controllers observe
the model. When the model changes, the views react. In this case the
actual text field view is notified that the reading object has
changed, and invokes the method defined as the aspect for that text
field - in this case #actual - and sets its value to the result. (It
does something similar for the color, but this raises its own specters
that I'll get to in a moment.)</p>

<p>You'll notice that the text field controller didn't set the
      value in the view itself, it updated the model and then just let
      the observer mechanism take care of the updates. This is quite
      different to the forms and controls approach where the form
      updates the control and relies on data binding to update the
      underlying record-set. These two styles I describe as patterns:
      <a href="https://martinfowler.com/eaaDev/FlowSynchronization.html">Flow Synchronization</a> and 
<a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a>. These two patterns
describe alternative ways of handling the triggering of
synchronization between screen state and session state. Forms and
Controls do it through the flow of the application manipulating the
various controls that need to be updated directly. MVC does it by
making updates on the model and then relying of the observer
relationship to update the views that are observing that model.</p>

<p><a href="https://martinfowler.com/eaaDev/FlowSynchronization.html">Flow Synchronization</a> is even more
      apparent when data binding isn't present. If the application
      needs to do synchronization itself, then it was typically done
      at important point in the application flow - such as when
      opening a screen or hitting the save button.</p>

<p>One of the consequences of <a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a> is that the controller is very
      ignorant of what other widgets need to change when the user
      manipulates a particular widget. While the form needs to keep
      tabs on things and make sure the overall screen state is
      consistent on a change, which can get pretty involved with
      complex screens, the controller in <a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a> can ignore all this.</p>

<p>This useful ignorance becomes particularly handy if there are
multiple screens open viewing the same model objects. The classic MVC
example was a spreadsheet like screen of data with a couple of
different graphs of that data in separate windows. The spreadsheet
window didn't need to be aware of what other windows were open, it
just changed the model and <a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a> took care of the rest. With
      <a href="https://martinfowler.com/eaaDev/FlowSynchronization.html">Flow Synchronization</a> it would need some way
of knowing which other windows were open so it tell them to
refresh.</p>

<p>While <a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a> is nice
      it does have a downside. The problem with <a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a> is the core problem of the
      observer pattern itself - you can't tell what is happening by
      reading the code. I was reminded of this very forcefully when
      trying to figure out how some Smalltalk 80 screens worked. I
      could get so far by reading the code, but once the observer
      mechanism kicked in the only way I could see what was going on
      was via a debugger and trace statements. Observer behavior is
      hard to understand and debug because it's implicit behavior.</p>

<p>While the different approaches to synchronization are
      particularly noticeable from looking at the sequence diagram,
      the most important, and most influential, difference is MVC's
      use of <a href="https://martinfowler.com/eaaDev/SeparatedPresentation.html">Separated Presentation</a>. Calculating
      the variance between actual and target is domain behavior, it is
      nothing to do with the UI. As a result following <a href="https://martinfowler.com/eaaDev/SeparatedPresentation.html">Separated Presentation</a> says we should place this in the
      domain layer of the system - which is exactly what the reading
      object represents. When we look at the reading object, the
      variance feature makes complete sense without any notion of the
      user interface.</p>

<p>At this point, however, we can begin to look at some
      complications. There's two areas where I've skipped over some
      awkward points that get in the way of MVC theory. The first
      problem area is to deal with setting the color of the
      variance. This shouldn't really fit into a domain object, as the
      color by which we display a value isn't part of the domain. The
      first step in dealing with this is to realize that part of the
      logic is domain logic. What we are doing here is making a
      qualitative statement about the variance, which we could term as
      good (over by more than 5%), bad (under by more than 10%), and normal
      (the rest). Making that assessment is certainly domain language,
      mapping that to colors and altering the variance field is view
      logic. The problem lies in where we put this view logic - it's
      not part of our standard text field.</p>

<p>This kind of  problem was faced by early smalltalkers and they came
      up with some solutions. The solution I've shown above is the dirty one
      - compromise some of the purity of the domain in order to make
        things work. I'll admit to the occasional impure act - but I
        try not to make a habit of it.</p>

<p>We could do pretty much what Forms and Controls does - have
the assessment screen view observe the variance field view, when the
variance field changes the assessment screen could react and set the
variance field's text color. Problems here include yet more use of
the observer mechanism - which gets exponentially more complicated the
more you use it - and extra coupling between the various views.</p>

<p>A way I would prefer is to build a new type of the UI
      control. Essentially what we
      need is a UI control that asks the domain for a qualitative
      value, compares it to some internal table of values and colors,
      and sets the font color accordingly. Both the table and message
      to ask the domain object would be set by the assessment view as it's
      assembling itself, just as it sets the aspect for the field to
      monitor. This approach could work very well if I can easily subclass
      text field to just add the extra behavior. This obviously depends
      on how well the components are designed to enable sub-classing -
      Smalltalk made it very easy - other environments can make it
      more difficult.</p>

<div class="figure " id="uiArchs_mvc-withSubWidget-seq.gif"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/mvc-withSubWidget-seq.gif">
<p class="photoCaption">Figure 7: Using a special
      subclass of text field that can be configured to determine the color.</p>
</div>

<div class="clear"></div>

<p>The final route is to make a new kind of model object, one
      that's oriented around around the screen, but is still
      independent of the widgets. It would be the model for the
      screen. Methods that were the same as those on the reading
      object would just be delegated to the reading, but it would add
      methods that supported behavior relevant only to the UI, such as
      the text color.</p>

<div class="figure " id="uiArchs_mvc-withPM-seq.gif"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/mvc-withPM-seq.gif">
<p class="photoCaption">Figure 8: Using an intermediate <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> to handle view logic.</p>
</div>

<div class="clear"></div>

<p>This last option works well for a number of cases and, as
      we'll see, became a common route for Smalltalkers to follow - I
      call this a <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> because it's
      a model that is really designed for and thus part of the
      presentation layer.</p>

<p>The <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> works well also
      for another presentation logic problem - presentation
      state. The basic MVC notion assumes that all the state of the
      view can be derived from the state of the model. In this case
      how do we figure out which station is selected in the list box?
      The <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> solves this for us by
      giving us a place to put this kind of state. A similar problem occurs
      if we have save buttons that are only enabled if data has
      changed - again that's state about our interaction with the
      model, not the model itself.</p>

<p>So now I think it's time for some soundbites on MVC.</p>

<ul>
<li>Make a strong separation between presentation (view &amp;
        controller) and domain (model) - <a href="https://martinfowler.com/eaaDev/SeparatedPresentation.html">Separated Presentation</a>.</li>

<li>Divide GUI widgets into a controller (for reacting to user
        stimulus) and view (for displaying the state of the
        model). Controller and view should (mostly) not communicate
        directly but through the model.</li>

<li>Have views (and controllers) observe the model to allow
        multiple widgets to update without needed to communicate
        directly - <a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a>.</li>
</ul>
</div>

<div id="VisualworksApplicationModel"><hr class="topSection">
<h2>VisualWorks Application Model</h2>

<p>As I've discussed above, Smalltalk 80's MVC was very
      influential and had some excellent features, but also some
      faults. As Smalltalk developed in the 80's and 90's this led to
      some significant variations on the classic MVC model. Indeed one
      could almost say that MVC disappeared, if you consider the
      view/controller separation to be an essential part of MVC -
      which the name does imply.</p>

<p>The things that clearly worked from MVC were <a href="https://martinfowler.com/eaaDev/SeparatedPresentation.html">Separated Presentation</a> and <a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a>. So these stayed as Smalltalk
      developed - indeed for many people they were the key element of
      MVC.</p>

<p>Smalltalk also fragmented in these years. The basic ideas of
      Smalltalk, including the (minimal) language definition remained
      the same, but we saw multiple Smalltalks develop with different
      libraries. From a UI perspective this became important as
      several libraries started using native widgets, the controls
      used by the Forms and Controls style.</p>

<p>Smalltalk was originally developed by Xerox Parc labs and
they span off a separate company, ParcPlace, to market and develop
Smalltalk. ParcPlace Smalltalk was called VisualWorks and made a point
of being a cross-platform system. Long before Java you could take a
Smalltalk program written in Windows and run it right away on
Solaris. As a result VisualWorks didn't use native widgets and kept
the GUI completely within Smalltalk.</p>

<p>In my discussion of MVC I finished with some problems of MVC
- particularly how to deal with view logic and view state. VisualWorks
refined its framework to deal with this by coming up with a construct
called the Application Model - a construct that moves towards
<a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>. The idea of using something like
a <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> wasn't new to VisualWorks - the
original Smalltalk 80 code browser was very similar, but the
VisualWorks Application Model baked it fully into the framework.</p>

<p>A key element of this kind of Smalltalk was the idea of
      turning properties into objects. In our usual notion of objects
      with properties we think of a Person object having properties
      for name and address. These properties may be fields, but could
      be something else. There is usually a standard convention for
      accessing the properties: in Java we would see <code>temp = aPerson.getName()</code> and
      <code>aPerson.setName("martin")</code>, in C# it would <code>temp = aPerson.name</code> and <code>aPerson.name = "martin"</code>.</p>

<p>A <b>Property Object</b> changes this by having the property return
      an object that wraps the actual value. So in VisualWorks when we
      ask for a name we get back a wrapping object. We then get the
      actual value by asking the wrapping object for its value. So
      accessing a person's name would use <code>temp = aPerson name
      value</code> and <code>aPerson name value: 'martin'</code></p>

<p>Property objects make the mapping between widgets and model a
      little easier. We just have to tell the widget what message to
      send to get the corresponding property, and the widget knows to
      access the proper value using <code>value</code> and
      <code>value:</code>. VisualWorks's property objects also allow
      you to set up observers with the message onChangeSend: aMessage
      to: anObserver.</p>

<p>You won't actually find a class called property object in
      Visual Works. Instead there were a number of classes that
      followed the value/value:/onChangeSend: protocol. The simplest
      is the ValueHolder - which just contains its value. More
      relevant to this discussion is the AspectAdaptor. The
      AspectAdaptor allowed a property object to wrap a property of
      another object completely. This way you could define a property
      object on a PersonUI class that wrapped a property on a Person
      object by code like</p>

<pre>adaptor := AspectAdaptor subject: person
adaptor forAspect: #name
adaptor onChangeSend: #redisplay to: self
</pre>

<p>So let's see how the application model fits into our running
      example.</p>

<div class="figure " id="uiArchs_appModel-cd.gif"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/appModel-cd.gif">
<p class="photoCaption">Figure 9: Class diagram for visual
      works application model on the running example</p>
</div>

<div class="clear"></div>

<p>The main difference between using an application model and
      classic MVC is that we now have an intermediate class between
      the domain model class (Reader) and the widget - this is the
      application model class. The widgets don't access the domain
      objects directly - their model is the application model. Widgets
      are still broken down into views and controllers, but unless
      you're building new widgets that distinction isn't important.</p>

<p>When you assemble the UI you do so in a UI painter, while in
      that painter you set the aspect for each widget. The aspect
      corresponds to a method on the application model that returns a
      property object. </p>

<div class="figure " id="uiArchs_appModelNoColor-seq.gif"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/appModelNoColor-seq.gif">
<p class="photoCaption">Figure 10: Sequence diagram
      showing how updating the actual value updates the variance
      text.</p>
</div>

<div class="clear"></div>

<p><a href="https://martinfowler.com/eaaDev/uiArchs.html#uiArchs_appModelNoColor-seq.gif"> Figure 10</a> shows how
      the basic update sequence works. When I change a value in text
      field, that field then updates the value in the property object
      inside the application model. That update follows through to the
      underlying domain object, updating its actual value.</p>

<p>At this point the observer relationships kick in. We need to
      set things up so that updating the actual value causes the
      reading to indicate that it has changed. We do this by putting a
      call in the modifier for actual to indicate that the reading
      object has changed - in particular that the variance aspect has
      changed. When setting up the aspect adaptor for variance it's
      easy to tell it to observe the reader, so it picks up the update
      message which it then forwards to its text field. The text field
      then initiates getting a new value, again through the aspect adaptor.</p>

<p>Using the application model and property objects like this
      helps us wire up the updates without having to write much
      code. It also supports fine-grained synchronization (which I
      don't think is a good thing).</p>

<p>Application models allow us to separate behavior and state that's
      particular to the UI from real domain logic. So one of the
      problems I mentioned earlier, holding the currently selected
      item in a list, can be solved by using a particular kind of
      aspect adaptor that wraps the domain model's list and also
      stores the currently selected item.</p>

<p>The limitation of all this, however, is that for more complex
      behavior you need to construct special widgets and property
      objects. As an example the provided set of objects don't provide
      a way to link the text color of the variance to the degree of
      variance. Separating the application and domain models does
      allow us to separate the decision making in the right way, but
      then to use widgets observing aspect adapters we need to make
      some new classes. Often this was seen as too much work, so we
      could make this kind of thing easier by allowing the application
      model to access the widgets directly, as in <a href="https://martinfowler.com/eaaDev/uiArchs.html#uiArchs_appModelColoring-seq.gif"> Figure 11</a>.</p>

<div class="figure " id="uiArchs_appModelColoring-seq.gif"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/appModelColoring-seq.gif">
<p class="photoCaption">Figure 11: Application Model
      updates colors by manipulating widgets directly.</p>
</div>

<div class="clear"></div>

<p>Directly updating the widgets like this is not part of
      <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>, which is why the visual
      works application model isn't truly a <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>. This need to manipulate the widgets directly
      was seen by many as a bit of a dirty workaround and helped develop the
      Model-View-Presenter approach.</p>

<p>So now the soundbites on Application Model</p>

<ul>
<li>Followed MVC in using <a href="https://martinfowler.com/eaaDev/SeparatedPresentation.html">Separated Presentation</a> and <a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a>.</li>

<li>Introduced an intermediate application model as a home for
        presentation logic and state - a partial development of <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>.</li>

<li>Widgets do not observe domain objects directly, instead
        they observe the application model.</li>

<li>Made extensive use of Property Objects to help connect the
        various layers and to support the fine grained synchronization
        using observers.</li>

<li>It wasn't the default behavior for the application model
        to manipulate widgets, but it was commonly done for
        complicated cases.</li>
</ul>
</div>

<div id="Model-view-presentermvp"><hr class="topSection">
<h2>Model-View-Presenter (MVP)</h2>

<p>MVP is an architecture that first appeared in IBM and more
      visibly at Taligent during the 1990's. It's most commonly referred via
      the <a href="http://www.wildcrest.com/Potel/Portfolio/mvp.pdf">Potel</a> paper. The idea was further
      popularized and described by the developers of <a href="http://www.object-arts.com/papers/TwistingTheTriad.PDF">Dolphin Smalltalk</a>. As we'll see the
      two descriptions don't entirely mesh but the basic idea
      underneath it has become popular.</p>

<p>To approach MVP I find it helpful to think about a
significant mismatch between two strands of UI thinking. On the one
hand is the Forms and Controller architecture which was the mainstream
approach to UI design, on the other is MVC and its derivatives. The
Forms and Controls model provides a design that is easy to understand
and makes a good separation between reusable widgets and application
specific code. What it lacks, and MVC has so strongly, is <a href="https://martinfowler.com/eaaDev/SeparatedPresentation.html">Separated Presentation</a> and indeed the context of
programming using a <a href="https://martinfowler.com/eaaCatalog/domainModel.html">Domain Model</a>. I see MVP
as a step towards uniting these streams, trying to take the best from
each.</p>

<p>The first element of <a href="http://www.wildcrest.com/Potel/Portfolio/mvp.pdf">Potel</a> is to treat
      the view as a structure of widgets, widgets that correspond to the
      controls of the Forms and Controls model and remove any
      view/controller separation. The view of MVP is a structure of
      these widgets. It doesn't contain any behavior that describes
      how the widgets react to user interaction.</p>

<p>The active reaction to user acts lives in a separate
      presenter object. The fundamental handlers
      for user gestures still exist in the widgets, but these handlers
      merely pass control to the presenter. </p>

<p>The presenter then decides how to react to the event. <a href="http://www.wildcrest.com/Potel/Portfolio/mvp.pdf">Potel</a> discusses this interaction primarily in
      terms of actions on the model, which it does by a system of
      commands and selections. A useful thing to highlight here is the
      approach of packaging all the edits to the model in a command -
      this provides a good foundation for providing undo/redo behavior.</p>

<p>As the Presenter updates the model, the view is updated
      through the same <a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a>
      approach that MVC uses.</p>

<p>The <a href="http://www.object-arts.com/papers/TwistingTheTriad.PDF">Dolphin</a>
      description is similar. Again the main similarity is the
      presence of the presenter. In the Dolphin
      description there isn't the structure of the presenter acting on
      the model through commands and selections. There is also
      explicit discussion of the presenter manipulating the view
      directly. Potel doesn't talk about whether presenters should do
      this or not, but for Dolphin this ability was essential to
      overcoming the kind of flaw in Application Model that made it
      awkward for me to color the text in the variation field.</p>

<p>One of the variations in thinking about MVP is the degree to
      which the presenter controls the widgets in the view. On one
      hand there is the case where all view
      logic is left in the view and the presenter doesn't get involved
      in deciding how to render the model. This style is the one implied by
      <a href="http://www.wildcrest.com/Potel/Portfolio/mvp.pdf">Potel</a>. The direction behind <a href="http://www.object-arts.com/papers/TwistingTheTriad.PDF">Bower and McGlashan</a> was what I'm calling <a href="https://martinfowler.com/eaaDev/SupervisingPresenter.html">Supervising Controller</a>,
      where the view handles a good deal of the view logic that can be
      described declaratively and the presenter then comes in to handle more
      complex cases. </p>

<p>You can also move all
      the way to having the presenter do all the manipulation of the
      widgets. This style, which I call <a href="https://martinfowler.com/eaaDev/PassiveScreen.html">Passive View</a>
 isn't part of
      the original descriptions of MVP but got developed as people
      explored testability issues. I'm going to talk about that style
      later, but that style is one of the flavors of MVP. </p>

<p>Before I contrast MVP with what I've discussed
      before I should mention that both MVP papers here do this too -
      but not quite with the same interpretation I have. Potel implies
      that MVC controllers were overall coordinators - which isn't how
      I see them. Dolphin talks a lot about issues in MVC, but by MVC
      they mean the VisualWorks Application Model design rather than
      classic MVC that I've described (I don't blame them for that -
      trying to get information on classic MVC isn't easy now let
      alone then.)</p>

<p>So now it's time for some contrasts:</p>

<ul>
<li>Forms and Controls: MVP has a model and the presenter is
        expected to manipulate this model with <a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a> then updating the
        view. Although direct access to the widgets is allowed, this
        should be in addition to using the model not the first choice.</li>

<li>MVC: MVP uses a <a href="https://martinfowler.com/eaaDev/SupervisingPresenter.html">Supervising Controller</a> to
        manipulate the model. Widgets hand off user gestures to the
        <a href="https://martinfowler.com/eaaDev/SupervisingPresenter.html">Supervising Controller</a>. Widgets aren't separated into
        views and controllers. You can think of presenters as being
        like controllers but without the initial handling of the user
        gesture. However it's also important to note that presenters
        are typically at the form level, rather than the widget level
      - this is perhaps an even bigger difference.</li>

<li>Application Model: Views hand off events to the presenter
        as they do to the application model. However the view may update
        itself directly from the domain model, the presenter doesn't
        act as a <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>. Furthermore
        the presenter is welcome to directly access widgets for
        behaviors that don't fit into the <a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a>. </li>
</ul>

<p>There are obvious similarities between MVP presenters and MVC
      controllers, and presenters are a loose form of MVC
      controller. As a result a lot of designs will follow the MVP
      style but use 'controller' as a synonym for presenter. There's a
      reasonable argument for using controller generally when we are
      talking about handling user input.</p>

<div class="figure " id="uiArchs_mvp-seq.gif"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/mvp-seq.gif">
<p class="photoCaption">Figure 12: Sequence diagram of the actual
      reading update in MVP.</p>
</div>

<div class="clear"></div>

<p>Let's look at an MVP (<a href="https://martinfowler.com/eaaDev/SupervisingPresenter.html">Supervising Controller</a>) version of the ice-cream monitor
      (<a href="https://martinfowler.com/eaaDev/uiArchs.html#uiArchs_mvp-seq.gif"> Figure 12</a>). It starts much the
      same as the Forms and Controls version - the actual text field
      raises an event when its text is changed, the presenter listens
      to this event and gets the new value of the field. At this point
      the presenter updates the reading domain object, which the
      variance field observes and updates its text with. The last part
      is the setting of the color for the variance field, which is
      done by the presenter. It gets the category from the reading and
      then updates the color of the variance field.</p>

<p>Here are the MVP soundbites:</p>

<ul>
<li>User gestures are handed off by the widgets to a <a href="https://martinfowler.com/eaaDev/SupervisingPresenter.html">Supervising Controller</a>.</li>

<li>The presenter coordinates changes in a domain model.</li>

<li>Different variants of MVP handle view updates
        differently. These vary from using <a href="https://martinfowler.com/eaaDev/MediatedSynchronization.html">Observer Synchronization</a> to having the presenter doing
        all the updates with a lot of ground in-between.</li>
</ul>
</div>

<div id="HumbleView"><hr class="topSection">
<h2>Humble View</h2>

<p>In the past few years there's been a strong fashion for
      writing self-testing code. Despite
      being the last person to ask about fashion sense, this is a
      movement that I'm thoroughly immersed in. Many of my colleagues
      are big fans of xUnit frameworks, automated regression tests, Test-Driven
      Development, Continuous Integration and similar buzzwords.</p>

<p>When people talk about self-testing code user-interfaces
      quickly raise their head as a problem. Many people find that
      testing GUIs to be somewhere between tough and impossible. This
      is largely because UIs are tightly coupled into the overall UI
      environment and difficult to tease apart and test in pieces.</p>

<p>Sometimes this test difficulty is over-stated. You can often
      get surprisingly far by creating widgets and manipulating them in
      test code. But there are occasions where this is impossible, you
      miss important interactions, there are threading issues, and the
      tests are too slow to run.</p>

<p>As a result there's been a steady movement to design UIs in
      such a way that minimizes the behavior in objects that are
      awkward to test. Michael Feathers crisply summed up this
      approach in <a href="http://www.objectmentor.com/resources/articles/TheHumbleDialogBox.pdf">The Humble Dialog
      Box</a>. <a href="http://xunitpatterns.com/">Gerard Meszaros</a> generalized this notion to idea of a
      <b>Humble Object</b> - any object that is difficult to test should have
      minimal behavior. That way if we are unable to include it in our
      test suites we minimize the chances of an undetected
      failure.</p>

<p><a href="http://www.objectmentor.com/resources/articles/TheHumbleDialogBox.pdf">The Humble Dialog Box</a>
paper uses a presenter, but in a
much deeper way than the original MVP. Not just does the presenter decide how to react
to user events, it also handles the population of data in the UI
widgets themselves. As a result the widgets no longer have, nor need,
visibility to the model; they form a  
<a href="https://martinfowler.com/eaaDev/PassiveScreen.html">Passive View</a>, manipulated by the presenter.</p>

<p>This isn't the only way to make the UI humble. Another
      approach is to use  <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>, although then you do need a bit more
      behavior in the widgets, enough for the widgets to know how to
      map themselves to the <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>.</p>

<p>The key to both approaches is that by testing the presenter
      or by testing the presentation model, you test most of the risk
      of the UI without having to touch the hard-to-test widgets. </p>

<p>With <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> you do this by
      having all the actual decision making made by the <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>. All user events and display logic is
      routed to the <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>, so that
      all the widgets have to do is map themselves to properties of
      the <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>. You can then test
      most of the behavior of the <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> without any widgets being present -
      the only remaining risk lies in the widget mapping. Provided that
      this is simple you can live with not testing it. In this case
      the screen isn't quite as humble as with the <a href="https://martinfowler.com/eaaDev/PassiveScreen.html">Passive View</a> approach, but the difference is small.</p>

<p>Since <a href="https://martinfowler.com/eaaDev/PassiveScreen.html">Passive View</a> makes the widgets
      entirely humble, without even a mapping present, <a href="https://martinfowler.com/eaaDev/PassiveScreen.html">Passive View</a> eliminates even the small risk present
      with <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>. The cost however is
      that you need a <a href="http://xunitpatterns.com/Test%20Double.html">Test Double</a> to mimic the
      screen during your test runs - which is extra machinery you need
      to build.</p>

<p>A similar trade-off exists with <a href="https://martinfowler.com/eaaDev/SupervisingPresenter.html">Supervising Controller</a>. Having the view do simple mappings
      introduces some risk but with the benefit (as with <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a>) of being able to specify simple
      mapping declaratively. Mappings will tend to be smaller for
      <a href="https://martinfowler.com/eaaDev/SupervisingPresenter.html">Supervising Controller</a> than for <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> as even complex updates will be
      determined by the <a href="https://martinfowler.com/eaaDev/PresentationModel.html">Presentation Model</a> and
      mapped, while a <a href="https://martinfowler.com/eaaDev/SupervisingPresenter.html">Supervising Controller</a> will manipulate
      the widgets for complex cases without any mapping involved.</p>
</div>

<hr class="bodySep">

<div class="end-box">
<div class="shares">
<div class="icons"><span class="label">Share:</span><a href="https://twitter.com/intent/tweet?url=https://martinfowler.com/eaaDev/uiArchs.html&amp;text=GUI%20Architectures%20%E2%9E%99" title="Share on Twitter"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/t_mini-a.png"></a><a href="https://facebook.com/sharer.php?u=https://martinfowler.com/eaaDev/uiArchs.html" title="Share on Facebook"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/fb-icon-20.png"></a><a href="https://plus.google.com/share?url=https://martinfowler.com/eaaDev/uiArchs.html" title="Share on Google Plus"><img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/gplus-16.png"></a></div>

<div class="comment">if you found this article useful, please share it. I appreciate the feedback and encouragement</div>
</div>

<div class="clear"></div>
</div>
</div>

<div class="appendix">
<div id="FurtherReading"><hr class="topSection">
<h2>Further Reading</h2>

<p>For recent articles that develop these ideas further, take a
      look at <a href="https://martinfowler.com/bliki/UiPatternsReadings.html">my bliki</a>.</p>
</div>

<div id="Acknowledgements"><hr class="topSection">
<h2>Acknowledgements</h2>

<p>Vassili Bykov generously let me have a copy of Hobbes - his
implementation of Smalltalk-80 version 2 (from the early 1980's)which
runs in modern VisualWorks. This provided me with a live example of
Model-View-Controller which was extremely helpful in answering
detailed questions of how it worked and how it was used in the default
image. Many people in those days considered it impractical to use a
virtual machine. I wonder what our prior selves would have thought to see
me running Smalltalk 80 in a virtual machine written in VisualWorks
running in the VisualWorks virtual machine on Windows XP running in a
VMware virtual machine running on Ubuntu.</p>
</div>
</div>

<div class="appendix">
<h2 id="SignificantRevisions">Significant Revisions</h2>

<p><i>18 July 2006: </i>First publication in development
  website.</p>
</div>
</div>

<div class="div" id="bottom-navmenu" style="display: none;">
<header class="navmenu">
<div class="nav-head">  <div class="search">
    <!-- SiteSearch Google -->
    <form method="GET" action="https://www.google.com/search">
      <input type="hidden" name="ie" value="UTF-8">
      <input type="hidden" name="oe" value="UTF-8">
      <input class="field" type="text" name="q" size="15" maxlength="255" value="">
      <button class="button" type="submit" name="btnG" value=" " title="Search">
      <input type="hidden" name="domains" value="martinfowler.com">
      <input type="hidden" name="sitesearch" value=""> 
      <input type="hidden" name="sitesearch" value="martinfowler.com">
    
  </button></form></div>

<div class="closediv">
<span class="close" title="close"></span>
</div>
</div>

<div class="nav-body">
<div class="topics">
<h2>Topics</h2>

<p><a href="https://martinfowler.com/design.html">Design</a></p>

<p><a href="https://refactoring.com/">Refactoring</a></p>

<p><a href="https://martinfowler.com/agile.html">Agile</a></p>

<p><a href="https://martinfowler.com/delivery.html">Continuous Delivery</a></p>

<p><a href="https://martinfowler.com/microservices">Microservices</a></p>

<p><a href="https://martinfowler.com/nosql.html">NoSQL</a></p>

<p><a href="https://martinfowler.com/dsl.html">DSL</a></p>
</div>

<div class="about">
<h2>about me</h2>

<p><a href="https://martinfowler.com/aboutMe.html">About</a></p>

<p><a href="https://martinfowler.com/books">Books</a></p>

<p><a href="https://martinfowler.com/faq.html">FAQ</a></p>
</div>

<div class="content">
<h2>content</h2>

<p><a href="https://martinfowler.com/videos.html">Videos</a></p>

<p><a href="https://martinfowler.com/tags">Content Index</a></p>

<p><a href="https://martinfowler.com/articles/eurogames">Board Games</a></p>

<p><a href="https://martinfowler.com/photos">Photography</a></p>
</div>

<div class="tw">
<h2>ThoughtWorks</h2>

<p><a href="https://thoughtworks.com/blogs">Blogs</a></p>

<p><a href="https://thoughtworks.com/careers">Careers</a></p>

<p><a href="https://thoughtworks.com/products">Products</a></p>
</div>

<div class="feeds">
<h2>follow</h2>

<p><a href="https://www.twitter.com/martinfowler">Twitter</a></p>

<p><a href="https://martinfowler.com/feed.atom">RSS</a></p>
</div>
</div>
</header>
</div>
<div id="footer">
<div class="tw-logo">
<a href="http://www.thoughtworks.com/">
<img src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/TW_smb.jpg">
</a>
</div>
<div class="menu-button">
<div class="icon-bars navmenu-button"></div>
</div>
<div class="copyright">
<p>© Martin Fowler | <a href="http://www.thoughtworks.com/privacy-policy">Privacy Policy</a> | <a href="https://martinfowler.com/aboutMe.html#disclosures">Disclosures</a></p>
</div>
</div>
<!-- Google Analytics -->
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-17005812-1', 'auto');
ga('send', 'pageview');
</script>
<script async="" src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/analytics.js.Download"></script>
<!-- End Google Analytics -->



<script src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/jquery-1.11.3.min.js.Download" type="text/javascript"></script>

<script src="file:///C:/Users/Tricuper/Documents/C%20-%20Dokumente/DAQ-Documents/2-Entwurf/0-Ressourcen/2019-06-25%20-%20Betreuertreffen/GUI%20Architectures_files/mfcom.js.Download" type="text/javascript"></script>


</body></html>